Coordination State Machine
Examples
noreferences

@@description

<p>This example has been built for the <a href="http://cserg0.site.uottawa.ca/cma2012/guidelines.htm">Comparing Modeling Approaches Workshop</a></p>

<p>Note that this file is too large for the 'Open In UmpleOnline' to work in most browsers. You will need to copy the text to the clipboard and paste it into <a href="http://try.umple.org">UmpleOnline</a>.</p>

@@example
// CoordinationStateMachine.ump
class Crisis {

  Integer timeoutInMs = 20000;
  
  Boolean thisSideInitiator;
  Boolean thisSideInitiatorOfTermination;
  
  Boolean routeAgreedYet;
  
  // True of we are the PSC, false of we are  
  // the FSC
  Boolean police;

  // Top level state machine
  crisisCoordinationStage {
  
    noCrisis {
      entry / {setThisSideInitiator(false);}
      // We are initiating and requesting 
      initiateCrisis / {
        setThisSideInitiator(true);
        sendInitiateCrisisRequestToOtherSC(); 
        } -> establishingCommunication;

      // We are responding to a request from 
      // the other SC 
      receiveInitiateCrisisRequest -> 
        establishingCommunication;
    }
    
    // 1. Establish communication 
    establishingCommunication {
      entry / {sendSecureCredentials();}
      secureCredentialsConfirmed -> 
        managingCrisis;
      
      // Return to idle after some delay
      after (timeoutInMs) 
        [!isThisSideInitiator()] -> noCrisis;
    }

    managingCrisis {
      // A crisis is underway. 
      entry / {initiateEmptyCrisis(); }

      exchangingDetails {
        // Requirement Scenario 2
        ourUpdateToCrisisData
          / {sendCrisisData();}
          -> exchangingDetails;
        receiveCrisisData
          / {updateCrisisData();}
          -> exchangingDetails;
        
        // Requirement Scenario 4
        ourVehicleDispatched
          / {sendVehicleDispatch();}
          -> exchangingDetails;
        receiveVehicleDispatched
          / {updateTheirDispatch();}
          -> exchangingDetails;
        
        // Requirement Scenario 5
        ourVehicleArrived
          / {sendVehicleArrived();}
          -> exchangingDetails;
        receiveVehicleArrived
          / {updateTheirArrival();}
          -> exchangingDetails;
        
        // Requirement Scenario 6
        ourVehicleMetObjective
          / {sendVehicleMetObjective();}
          -> exchangingDetails;
        receiveMetObjective
        / {updateTheirMetObjective();}
        -> exchangingDetails;
        
        // Requirement 5.a - breakdown
        breakdown / {dispatchAndUpdateOther();} 
          -> exchangingDetails;
        
      } // End of exchangingDetails
        //concurrent substate
      ||
      
      // 7. Both parties must agree to close 
      // the crisis; either can initiate
      crisisEndManagement {
      
        // Normal substate of crisisEndManagement - no end in sight yet
        ongoingCrisis {
        
          // We could initiate termination
          initiateTermination / {
            setThisSideInitiatorOfTermination(true);
            sendTerminationRequestToOtherSC();
            } -> waitingForTerminationConfirmation;
          receiveTerminationRequestFromOtherSC 
          -> 
            waitingForUserTerminationAgreement;
        }
        
        waitingForUserTerminationAgreement {
          do {confirmWithUserToTerminate();}
          confirmTermination -> tearDown;
          after (timeoutInMs) -> ongoingCrisis;
        }
            
        // Substate of where we are waiting for 
        // the other end to agree
        waitingForTerminationConfirmation {
          receiveTerminationConfirmation
            -> tearDown;
          
          // If the other side has not agreed, 
          // we keep the crisis active
          after (timeoutInMs) -> ongoingCrisis;
        }
        
        // End of crisis
        tearDown {
          entry / {deleteCrisis();}
          -> noCrisis;
        }
      } // End of crisisEndManagement 
        // concurrent substate
      ||

      // 3. Negotiating route plan
      negotiatingRoutePlan {
    
        // Negotiation happens in parallel with 
        // reporting timeout
        negotiation {
          entry / {setRouteAgreedYet(false);}
          informOfNumberOfVehicles
            / {sendNumberOfVehicles();}
            -> negotiation;
          receiveNumberOfVehicles [isPolice()] 
            -> planningRoute;
          receiveRouteProposal [!isPolice()]
            -> approvingRoute;
          
          // Requirement 3.3.a2.a1
          receiveNoAgreeableRoute
            [!isPolice()] -> noRouteAgreement;
          
          // The PSC plans the route -- only 
          // PSC can be in this state
          planningRoute {
             do {planRoute();}
             routePlanComplete
               / {sendPlanToFSC(); }
               -> awaitingRouteApproval;
             
             // Requirement 3.3.a2.a1 - no more 
             // possible routes
             noMoreRoutes
               / {sendNoMoreRoutesToFSC(); }
               -> noRouteAgreement;
          }

          // The FSC approves the route  -- 
          // only FSC can be in this state
          approvingRoute {
            do {userConfirmRouteAcceptable();}
            routeAcceptable
              / {sendApprovalToPSC();}
              -> routeAgreed;
            routeUnacceptable
              / {sendDisapprovalToFSC();}
              -> negotiation;
          }
          
          // The PSC awaits for approval from 
          // the FSC. Only the PSC can be in 
          // this state
          awaitingRouteApproval {
            receiveApprovalFromFSC
              -> routeAgreed;
            
            // Requirement 3.3.a - FSC 
            // disagrees
            receiveDisapprovalFromFSC / {
              addRouteToDisapprovedChoices(); 
              } -> planningRoute;
          }
          
          routeAgreed {
            entry / {setRouteAgreedYet(true);}
          }
          
          noRouteAgreement {
             // requirement 3.3.a2.a1
          }
        } 
        ||
        managingTimeliness {
          timeAcceptable {
            // Requirement 3.a1. Negotiations 
            // are taking excessive time
            after (timeoutInMs)
              [!isRouteAgreedYet()]
              -> timeUnacceptable;
          }
          timeUnacceptable {

            do {
              promptAndLogReasonForTimeout(); }
          }
        } 
      } 
    } 
  } 
} 
@@endexample