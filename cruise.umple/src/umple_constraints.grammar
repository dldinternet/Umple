// The master of this part of the Umple grammar is available at
// [*http://code.google.com/p/umple/source/browse/trunk/cruise.umple/src/umple_constraints.grammar*]

// Copyright: All contributors to the Umple Project
// This file is made available subject to the open source license found at:
// [*http://umple.org/license*]

// Constraints in Umple.
// This is currently under development. Constraint capability is being
// developed in agile increments. The first step, described below,
// allows limiting the values of attributes. Code generation is not currently enabled.
// Constraints may appear in classes (including association classes) 
// as well as in states.
precondition : [ [name]? pre: [[constraint]] ]
postcondition : [ [name]? post: [[constraint]] ]

invariant : [ ([name] :)? ([[constraint]]) ]
constraintToken : [[constraint]]

// A constraint is an expression optionally be surrounded in round brackets or negated
constraint- :  [[constraintBody]] |  [[constraintExpr]] [[linkingOp]]?
negativeConstraint : ! [[constraint]] | not [[constraint]] | ~ [[constraint]]

// A constraint body is a constraint expression (possibly with a linking operator such as && or ||). 
constraintBody- : [=brace:OPEN_ROUND_BRACKET] [[constraint]] [=brace:CLOSE_ROUND_BRACKET]
linkingOp : ( [=||] | [=andOp:and|&&|&] | [=orOp:or] ) [[constraintToken]]
constraintExpr- :  [[negativeConstraint]] | [[stringExpr]]|[[boolExpr]]|[[numExpr]]|[[associationExpr]]|[[statemachineExpr]]|[[genExpr]]| [[loneBoolean]] 

compoundExpr- : [[stringExpr]]|[[numExpr]]|[[boolExpr]]|[[genExpr]]

loneBoolean : [[constraintName]]

//must be a boolean
boolExpr :  [[constraintName]] [[equalityOp]] [=literal:true|false] | [=literal:true|false] [[equalityOp]]  [[constraintName]] | [=literal:true|false]

//must be string
stringExpr : [[constraintName]] [[equalityOp]] [[stringLit]] | [[stringLit]] [[equalityOp]] [[constraintName]]
stringLit- : " [**quote] " | ' [**quote] '

//basically the "other" catagory, contains everything that can be equal to something else
genExpr : [[constraintName]] [[equalityOp]] [[constraintName]]

//for floats, doubles and ints
numExpr : [[numNam]] [[ordinalOp]] [[numNam]] | [[constraintName]] [[equalityOp]] [[numLit]] | [[numLit]] [[equalityOp]] [[constraintName]]
numLit- : [!number:[0-9]+OPEN_ROUND_BRACKET[\\.][0-9]+CLOSE_ROUND_BRACKET?]
numNam- : [[numLit]] | [[constraintName]]

equalityOp- :  [[equalsOp]] | [[notequalsOp]] 

equalsOp- : [=equalsOp:==|equals]
notequalsOp- : [=notequalsOp:!=|/=|=!|=/=]

ordinalOp- : [[greaterOp]]|[[lessOp]]|[[moreOp]]|[[smallerOp]]

greaterOp- :[=greaterOp:greater|>=|=>|=>=]
lessOp- :[=lessOp:less|<=|=<|=<=]
moreOp- :[=moreOp:larger|>]
smallerOp- :[=smallerOp:smaller|<]

associationExpr : [[constraintName]] [[associationOps]] [[associationLit]]
associationOps- : [=firstOp:cardinality|has] ( [[ordinalOp]] | [[equalityOp]] | [=all] )?
associationLit : [[numLit]] [=elements]? | [[stringLit]] | [[constraintName]] | { [[associationLit]] ( , [[associationLit]] )* }

statemachineExpr : [[constraintName]] [[statemachineOps]] [[statemachineLit]]
statemachineOps- : [=isInOp:is in|isIn|state==] | [=isNotInOp:is not in|isNotIn|state!=]
statemachineLit- : [=state]? [[constraintName]]

constraintName : [=new]? [!name:[a-zA-Z_][a-zA-Z0-9_-]*] [[constraintIndexOperator]]* [[constraintParameterList]]? [[constraintScopeOperator]]?
constraintIndexOperator- : [ [!index:[0-9]+] ]
constraintScopeOperator :  ( . | -> ) [[constraintName]]
constraintParameterList : OPEN_ROUND_BRACKET [[constraintParameter]]? ( , [[constraintParameter]] )* CLOSE_ROUND_BRACKET
constraintParameter : [=boolLit:true|false] | [[stringLit]] | [[constraintName]] | [[numLit]]

// NOTE: Additional grammar parts deleted while testing is ongoing.
