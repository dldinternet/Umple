/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates Alloy code
  generate Alloy;
in your umple file, or the command line option
  -g Alloy

 */

use AlloyMetaModel.ump;
use AlloyUtility.ump;
use AlloySignature.ump;
use AlloyFact.ump;

namespace cruise.umple.compiler;

class AlloyGenerator
{
  depend cruise.umple.alloy.*;
  Utility utility = new Utility();
  
  
  public void generate(){
  
  	final String className = "UmpleObject";
    StringBuilder code = new StringBuilder(); 
       
    //This statement adds comment to model
    utility.commentModel(code,model);
    utility.printOpenStatement(className,"ordering",code);
    AlloyObject aObj = new AlloyObject();
    
    //Prints AlloyObject signature to be inherited by other signatures
    utility.addString(code,aObj.printObject(className));
  
    // Iterate through all classes and generate Alloy
    Set<UmpleClass> processedClass = new HashSet<UmpleClass>(); // needed to prevent double reflexive count
    for (UmpleClass uClass : model.getUmpleClasses())
    {      
      signaturePrep(uClass,className,code);
      for(Association assoc : uClass.getAssociations()){
        //Case of SymmetricReflexive Association
        if(analyzeAssociation(assoc) == 3){
                    
          NonReflexiveFact nrf = new NonReflexiveFact(assoc);
          utility.addString(code,nrf.print());
          
          //Symmetric relations
          SymmetricFact sf = new SymmetricFact(assoc);
          utility.addString(code,sf.print());
        }
      }
      //processedClass.add(uClass);
    }
    
    //Set<Association> processedAssociations = new HashSet<Association>(); // needed to prevent double reflexive count
             
    for(Association assoc : model.getAssociations()){
      utility.addNewLine(code,1);         
      //Case of Asymmetric association
      if(analyzeAssociation(assoc) == 1){
          
    	NoExtendedFact nExt = new NoExtendedFact(assoc); 
    	utility.addString(code,nExt.print());
    	NoSelfRelationFact nsr = new NoSelfRelationFact(assoc);
    	utility.addString(code,nsr.print()); 
      }
        
      //Case of bidirectional association
      if(analyzeAssociation(assoc) == 2){
        
    	BidirectionFact bidirect = new BidirectionFact(assoc);
    	utility.addString(code,bidirect.print());
      }
    }
    
    //This generates bidirectionality rules for every association within Umple model 
    terminateCode(code);
  }
  
  private void signaturePrep(UmpleClass uClass, String className,StringBuilder code){
    Signature sig = new Signature(uClass,className);
    utility.addString(code,sig.printSignature());
  }
  
  private Integer analyzeAssociation(Association assoc){
  	String rEndName = utility.getRightEndName(assoc),
  		lEndName = utility.getLeftEndName(assoc);
  	if(lEndName.equals(rEndName)){
  	  if(compareRoleNames(assoc) == true)
  	    return 3;
  	  return 1;
  	}
  	return 2;
  }
  
  private boolean compareRoleNames(Association assoc){
    if(assoc.getEnd(0).getDisplayRoleName().equals("")) return true;
    return false;
  }
  
  private void terminateCode(StringBuilder code) {
    model.setCode(code.toString());
    writeModel();
  } 
  
  // Output the Alloy file to a file with the .als suffix
  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".als";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating Alloy code." + e, e);
    }
  } 
}

