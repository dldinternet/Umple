/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Methods for the metamodel found in Umple.ump. Most of these are mixins.

 */


namespace cruise.umple.compiler;

/**
 * In Umple_Code.ump: Methods for manipulating the Model
 */
class UmpleModel
{
  public List<UmpleElement> getUmpleElements()
  {
    List<UmpleElement> all = new ArrayList<UmpleElement>();
    all.addAll(getUmpleClasses());
    all.addAll(getUmpleInterfaces());
    return all;
  }

  public UmpleInterface addUmpleInterface(String name)
  {
    UmpleInterface newInterface = getUmpleInterface(name);
    if (newInterface == null)
    {
      newInterface = new UmpleInterface(name);
      addUmpleInterface(newInterface);
    }
    return newInterface;
  }

  public UmpleClass addUmpleClass(String name)
  {
    UmpleClass newClass = getUmpleClass(name);
    if (newClass == null)
    {
      newClass = new UmpleClass(name, this);
      addUmpleClass(newClass);
    }
    return newClass;
  }

  public Association getAssociation(String name)
  {
    for (Association a : associations)
    {
      if (a.getName().equals(name))
      {
        return a;
      }
    }
    return null;
  }

  public AssociationClass addAssociationClass(String className)
  {
    AssociationClass newClass = (AssociationClass) getUmpleClass(className);
    if (newClass == null)
    {
      newClass = new AssociationClass(className);
      addUmpleClass(newClass);
    }
    return newClass;
  }

  public void addGenerate(String lang)
  {
    addGenerate(new GenerateTarget(lang, null));
  }

  public void addGenerate(Collection <?extends GenerateTarget> c)
  {
    generates.addAll(c);
  }

  public String getDefaultGenerate()
  {
    // Note that this method should be getDefaultGenerateLanguage
    // To avoid rippling changes throughout the code, the name is left as is 
    if (numberOfGenerates() == 0)
    {
      return null;
    }
    else
    {
      return getGenerate(0).getLanguage();
    }
  }

  public String getDefaultGeneratePath()
  {
    if (numberOfGenerates() == 0)
    {
      return null;
    }
    else
    {
      return getGenerate(0).getPath() == null ? "./" : getGenerate(0).getPath();
    }
  }

  public void clearGenerates()
  {
    generates.clear();
  }

  public UmpleClass getUmpleClass(String name)
  {
    for (UmpleClass aClass : getUmpleClasses())
    {
      if (aClass.getName().equals(name))
      {
        return aClass;
      }
    }
    return null;
  }

  public UmpleInterface getUmpleInterface(String name)
  {
    for (UmpleInterface aInterface : getUmpleInterfaces())
    {
      if (aInterface.getName().equals(name))
      {
        return aInterface;
      }
    }
    return null;
  }


  public StateMachine getStateMachineDefinition(String name)
  {
    for (StateMachine aStateMachine : getStateMachineDefinitions())
    {
      if (aStateMachine.getName().equals(name))
      {
        return aStateMachine;
      }
    }
    return null;
  }

  public boolean hasAnalyzer(String name)
  {
    return analyzers.containsKey(name);
  }
  
  public Analyzer getAnalyzer(String name)
  {
    return analyzers.get(name);
  }
/*
 * Creates a new parser, loads the input, parses, then analyses 
 */
  public void run()
  {
    boolean failed = false;
    String input;
    cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(this);
    UmpleParser analyzer = new UmpleInternalParser("UmpleInternalParser",this,parser);
    ParseResult result = parser.parse(umpleFile);
    
    failed = !result.getWasSuccess();
    lastResult = result;

    if(!failed)
      result = analyzer.analyze(getShouldGenerate());

    failed |= !result.getWasSuccess();

    if(failed || result.getHasWarnings())
      throw new UmpleCompilerException(result.toString(),null);
  }

/*
 * Creates a generator for you based on the provided Language
 */
  public CodeGenerator newGenerator(String language)
  {
    boolean foundGenerator;
    
    String realLanguage = language;
    if (language.equals("Cpp")) realLanguage="RTCpp";
    else if (language.equals("SimpleCpp")) realLanguage="Cpp";
    
    String className = StringFormatter.format("cruise.umple.compiler.{0}Generator",realLanguage); 
    Class<?> classDefinition = null;
    try {
      classDefinition = Class.forName(className);
      CodeGenerator generator = (CodeGenerator) classDefinition.newInstance();
      generator.setModel(this);
      return generator;
    }
    catch (ClassNotFoundException cnf) {
      System.err.println("Code generator "+realLanguage+ " not found. Check spelling. Specify --help.");
      System.exit(-1);
      throw new RuntimeException(cnf);
    }
    catch (Exception ex2) {
      throw new RuntimeException("Unable to instantiate "+realLanguage+ ".",ex2);
    }
  }


/*
 * Generates the actual code for each generation target
 */
  public void generate()
  {
    boolean foundGenerator;
    try
    {
      for (GenerateTarget target : getGenerates())
      {
        CodeGenerator generator = newGenerator(target.getLanguage());
        generator.setOutput(target.getPath());
        CodeBlock.languageUsed = target.getLanguage();
        for (String subopt : target.getSuboptions()) {
        	 generator.setSuboption(subopt);
        }
        generator.generate();
      }
    }
    catch (Exception ex)
    {
      System.err.println("Code Generator error. Unable to generate code: Stack Trace Follows.");
      cruise.umple.util.ExceptionDumper.dumpCompilerError(ex);
      System.exit(-1);    
    }
   }
   

  public Coordinate getDefaultClassPosition(int numDefaults)
  {
    int xIndex  = 0;
    int yIndex = 0;
    int yOffset = 0;
    int xOffset = 0;

    xIndex = (numDefaults-1) / (maxYLevels);
    yIndex = (numDefaults-1) % (maxYLevels);
    yOffset = (yIndex * levelOffset.getY()) + initialOffset.getY();
    xOffset = (xIndex * levelOffset.getX()) + initialOffset.getX();

    return new Coordinate(xOffset,yOffset,classSize.getWidth(),classSize.getHeight());
  }

  public Coordinate[] getDefaultAssociationPosition(Association a)
  {
    Coordinate[] defaults = new Coordinate[2];
    int offsetY = offsetFromEdge.getX();
    int offsetX = offsetFromEdge.getY();

    String classOne = a.getEnd(0).getClassName();
    String classTwo = a.getEnd(1).getClassName();
    
    if(getUmpleTraitTypeParameter(classOne) || getUmpleTrait(classOne)!=null) return null;
    if(getUmpleTraitTypeParameter(classTwo) || getUmpleTrait(classTwo)!=null) return null;
    
    Coordinate classOnePos = getUmpleClass(classOne).getCoordinates();
    Coordinate classTwoPos = getUmpleClass(classTwo).getCoordinates();

    if (classOne.equals(classTwo))
    {
      return getDefaultReflexiveAssociationPosition(a);
    }

    int num = 1;
    String tempClass1 = "";
    String tempClass2 = "";
    for (Association temp : getAssociations())
    {
      tempClass1 = temp.getEnd(0).getClassName();
      tempClass2 = temp.getEnd(1).getClassName();

      if (temp.getName().equals(a.getName()) &&
          tempClass1.equals(classOne)        && 
          tempClass2.equals(classTwo)) 
      {
        break; 
      }

      if (tempClass1.equals(classOne) && tempClass2.equals(classTwo)){ ++num; break; }
      else if (tempClass1.equals(classTwo) && tempClass2.equals(classOne)){ ++num; break; }
    }

    Coordinate classOneNoX = new Coordinate(classOnePos.getX(),classOnePos.getY(),classOnePos.getWidth(),classOnePos.getHeight());
    Coordinate classTwoNoX = new Coordinate(classTwoPos.getX(),classTwoPos.getY(),classTwoPos.getWidth(),classTwoPos.getHeight());
    Coordinate classOneNoY = new Coordinate(classOnePos.getX(),classOnePos.getY(),classOnePos.getWidth(),classOnePos.getHeight());
    Coordinate classTwoNoY = new Coordinate(classTwoPos.getX(),classTwoPos.getY(),classTwoPos.getWidth(),classTwoPos.getHeight());
    classOneNoX.setX(0);
    classTwoNoX.setX(0);
    classOneNoY.setY(0);
    classTwoNoY.setY(0);
    String whereVert = classOneNoX.whereIs(classTwoNoX);
    String whereHorz = classOneNoY.whereIs(classTwoNoY);

    // alternative 1: left/right wall of class one to left/right wall of class two
    int offsetOneX = whereHorz.equals("right")? classOnePos.getWidth() : 0;
    int offsetTwoX = whereHorz.equals("right")? 0 : classTwoPos.getWidth();
    int offsetOneY = num > 1 ? (num+1)*offsetY : offsetY;
    int offsetTwoY = num > 1 ? (num+1)*offsetY : offsetY;
    Coordinate offsetOne = new Coordinate(offsetOneX, offsetOneY, 0, 0);
    Coordinate offsetTwo = new Coordinate(offsetTwoX, offsetTwoY, 0, 0);
    Coordinate start = new Coordinate(classOnePos.getX() + offsetOne.getX(),
        classOnePos.getY() + offsetOne.getY(),
        0,0);
    Coordinate end = new Coordinate(  classTwoPos.getX() + offsetTwo.getX(),
        classTwoPos.getY() + offsetTwo.getY(),
        0,0);

    int distance = start.distanceTo(end);

    // alternative 2: top/bottom wall of class one to top/bottom wall of class two
    int altXOne = num*offsetX;
    int altXTwo = num*offsetX;
    int altYOne = whereVert.equals("top")? 0 : classOnePos.getHeight();
    int altYTwo = whereVert.equals("top")? classTwoPos.getHeight() : 0;
    Coordinate altOffsetOne = new Coordinate(altXOne, altYOne, 0, 0);
    Coordinate altOffsetTwo = new Coordinate(altXTwo, altYTwo, 0, 0);
    Coordinate altStart = new Coordinate(classOnePos.getX() + altOffsetOne.getX(),
        classOnePos.getY() + altOffsetOne.getY(),
        0,0);
    Coordinate altEnd = new Coordinate(  classTwoPos.getX() + altOffsetTwo.getX(),
        classTwoPos.getY() + altOffsetTwo.getY(),
        0,0);

    int altDistance = altStart.distanceTo(altEnd);

    // choose alternative that generates the shortest line
    if (altDistance < distance)
    {
      defaults[0] = altOffsetOne;
      defaults[1] = altOffsetTwo;
    } 
    else
    {
      defaults[0] = offsetOne;
      defaults[1] = offsetTwo;
    }

    return defaults;
  }

  private Coordinate[] getDefaultReflexiveAssociationPosition(Association a)
  {
    Coordinate[] defaults = new Coordinate[2];
    String name  = a.getEnd(0).getClassName();
    Coordinate position = getUmpleClass(name).getCoordinates();

    // determine which corner the association should be positioned at
    int index = 0;
    for (int i=0; i < numberOfAssociations(); i++)
    {
      Association current = getAssociation(i);
      if (current.getEnd(0).getClassName().equals(name) && current.getEnd(1).getClassName().equals(name))
      {    
        if (current.numberOfPositions() > 0)
        {
          if (current.getPosition(0).getStatus().equals(Coordinate.Status.Defaulted))
          {
            index += 1;
          }
        }
      }
    }

    Coordinate offsetOne = new Coordinate(0,0,0,0);
    Coordinate offsetTwo = new Coordinate(0,0,0,0);

    if (index % 4 == 0)
    {
      offsetOne.setX(reflexiveSegmentLength);
      offsetOne.setY(position.getHeight());
      offsetTwo.setX(0);
      offsetTwo.setY(position.getHeight() - reflexiveSegmentLength);
    }
    else if (index % 4 == 1)
    {
      offsetOne.setX(position.getWidth() - reflexiveSegmentLength);
      offsetOne.setY(position.getHeight());
      offsetTwo.setX(position.getWidth());
      offsetTwo.setY(position.getHeight() - reflexiveSegmentLength);
    }
    else if (index % 4 == 2)
    {
      offsetOne.setX(position.getWidth() - reflexiveSegmentLength);
      offsetOne.setY(0);
      offsetTwo.setX(position.getWidth());
      offsetTwo.setY(reflexiveSegmentLength);
    }
    else
    {
      offsetOne.setX(reflexiveSegmentLength);
      offsetOne.setY(0);
      offsetTwo.setX(0);
      offsetTwo.setY(reflexiveSegmentLength);
    }

    defaults[0] = offsetOne;
    defaults[1] = offsetTwo;

    return defaults;
  }
  
  
  public Map<String, CodeTranslator> getAllTranslators() {
    Map<String, CodeTranslator> allTranslators = new HashMap<String, CodeTranslator>();
    CodeGenerator tempCodeGen = null;
    for(GenerateTarget t : getGenerates())
    {
      if((tempCodeGen = newGenerator(t.getLanguage())) instanceof CodeTranslator) {        
        allTranslators.put(t.getLanguage(), (CodeTranslator)tempCodeGen);
      }
    }
    
    return allTranslators;
  }
}

/*
 */
class Key
{
  public boolean isProvided()
  {
    return isDefault || members.size() > 0;
  }

  public boolean isMember(UmpleVariable av)
  {
    if (av == null)
    {
      return false;
    }
    return indexOfMember(av.getName()) != -1;
  }  
}

/*
 */
class Depend
{
  public String getPackageName()
  {
    if (name == null || "".equals(name))
    {
      return "";
    }
    int dotIndex = name.lastIndexOf(".");
    return dotIndex >= 0 ? name.substring(0,dotIndex) : name;
  }
}

  /**
   * This is for cloning
   * Note: This code doesn't cover deep cloning. It's a combination of  shallow and deep cloning 
   */
class Method
{  
    /**
   * This is for cloning
   * Note: This code doesn't cover deep cloning. It's a combination of  shallow and deep cloning 
   */	
  public Method(Method another) {
	  this.isAbstract = another.getIsAbstract();
	  this.modifier = another.getModifier();
	  this.name = another.getName() ;
	  this.position = another.getPosition();
	  this.codePosition = another.getCodePosition();
	  this.endPosition = another.getEndPosition();
	  this.type = another.getType();
	  this.isImplemented = another.getIsImplemented();
	  this.methodParameters = new ArrayList<MethodParameter>();
	  for (MethodParameter mParameter : another.getMethodParameters()) {
		  this.methodParameters.add(new MethodParameter(mParameter));
	  }
	  if (another.getMethodBody()!=null){
		  this.methodBody = new MethodBody(another.getMethodBody());
	  } else{
		  this.methodBody = another.getMethodBody();
	  }
	  this. comments = another.getComments();  
  }
  
  public boolean getExistsInLanguage(String lang) 
  {
    if(getMethodBody().getExtraCode(lang)==null)
      return false;
    else 
      return true;
  }
  public String toString()
  {    
    StringBuffer methodBuffer = new StringBuffer();
    methodBuffer.append(" " + this.getType()+ " " + this.getName());
    methodBuffer.append("(");
    String paramName="";
    String paramType="";
    String aSingleParameter="";
    String isList="";
    String parameters = "";
    String finalParams= "";
    if (this.hasMethodParameters()){
      for (MethodParameter aMethodParam : this.getMethodParameters()) 
      {
        paramName = aMethodParam.getName();
        paramType = aMethodParam.getType();
        isList = aMethodParam.getIsList() ? " [] " : " ";
        aSingleParameter = paramType + isList + paramName;
        parameters += aSingleParameter + ",";
      }
      finalParams = parameters.substring(0, parameters.length()-1);
      methodBuffer.append(finalParams);
    }
    methodBuffer.append(")");
    methodBuffer.append("  {");
    methodBuffer.append(System.getProperty("line.separator"));
    methodBuffer.append(    this.getMethodBody().getExtraCode());
    methodBuffer.append(System.getProperty("line.separator"));
    methodBuffer.append("  }");
    return methodBuffer.toString();
  }
}

/*
 */
class MethodBody
{
  public MethodBody(MethodBody another) {
	codeblock = new CodeBlock(another.getCodeblock());
  }
  public MethodBody(String aValue)
  {
    this(new CodeBlock(aValue!=null ? aValue : ""));
  }
  public String getExtraCode(String lang)
  {
  return codeblock.getCode(lang);
  }
  public void setExtraCode(String code)
  {
    codeblock.setCode(code);
  }
  public void setExtraCode(String lang, String code)
  {
    codeblock.setCode(lang,code);
  }
}


class MethodParameter
{
  /**
   * This is for cloning
   * Note: This code doesn't cover deep cloning. It's a combination of  shallow and deep cloning 
   */
  public MethodParameter(MethodParameter another){
	super(another.getName(), another.getType(), another.getModifier(), another.getValue());
	this.isAutounique = another.getIsAutounique();
	this.isList = another.getIsList();
	this.isDerived = another.getIsDerived();
	this.isLazy = another.getIsLazy();
  }
  public String getFullType()
  {
    return this.getType() + (this.getIsList() ? "[]" : "");
  }
}

/*
 */
class CodeBlock
{
  public CodeBlock(CodeBlock another){
  	this.codes = new HashMap<String,String>();
  	this.codes.putAll(another.codes);
  }	
  public void ApplyTypeParameters(GeneralTPApplied inGeneralTPApplied){
	   if (inGeneralTPApplied == null) return;
	   Integer start=0,end=0;
	   boolean inProcess = false;
	   String internalCode = "";
	   for (String language : codes.keySet()) {
		   String code = codes.get(language);
		   start=0;
		   end=0;
		   inProcess = false;
		   internalCode = "";
		   for (int i=0;i<code.length();i++) {
		  		if (code.charAt(i)=='#' &&!inProcess){
		  			inProcess=true;
		  			start = i;
		  			continue;
		  		}
		  		if (code.charAt(i)=='#' && inProcess){
		  			inProcess=false;
		  			end=i;
		  			String strTemp = code.substring(start+1, end);
		  			if (inGeneralTPApplied.getParameterMapping().containsKey(strTemp)){
		  				internalCode = internalCode+inGeneralTPApplied.getParameterMapping().get(strTemp);
		  				continue;
		  			} else {
		  				internalCode = internalCode+"#"+strTemp+"#";
		  			}
		  			
		  		}			
		  		if (!inProcess){
		  			internalCode = internalCode+code.charAt(i);
		  		}	
			}
		   codes.put(language, internalCode);
	   }
  }
  public CodeBlock(String add)
  {
    this();
    codes.put("",add);
  }
  public CodeBlock(String lang, String add)
  {
    this();
    codes.put(lang,add);
  }
  public void setCode(String add)
  {
    if(add!=null)
      codes.put("",add);
    else
      codes.put("","");
  }
  public void setCode(String lang, String add)
  {
    if(add!=null)
      codes.put(lang,add);
    else
      codes.put(lang,"");
  }
  public String getCode()
  {
    return !codes.containsKey(languageUsed) ? "".equals(languageUsed) ? null : codes.get("") : codes.get(languageUsed);
  }
  public String getCode(String lang)
  {
    return codes.containsKey(lang)? codes.get(lang) : "";
  }
  public String toString(){
    String out = "";
    for(String next:codes.values())
    {
      out += next;
    }
    return out;
  }
}

/*
 */
class CodeInjection
{
  public CodeInjection(String a, String b, String c, UmpleClassifier d)
  {
    this(a,b,new CodeBlock(c), d);
  }
  public void setCode(String str)
  {
    snippet.setCode(str);
  }
  public String getCode()
  {
    if(constraint == null)
    {
      return snippet.getCode();
    }
    else
    {
      if("Java".equals(CodeBlock.languageUsed))
      {
        return StringFormatter.format((new JavaGenerator()).translate("Closed",getConstraint()),
  	                             snippet.getCode()
  	                             );
      }
      else if("Php".equals(CodeBlock.languageUsed))
      {
        return StringFormatter.format((new PhpGenerator()).translate("Closed",getConstraint()),
  	                             snippet.getCode()
                                     );
      }
      else if("Ruby".equals(CodeBlock.languageUsed))
      {
        return StringFormatter.format((new RubyGenerator()).translate("Closed",getConstraint()),
  	                             snippet.getCode()
                                     );
      }
      else if("Cpp".equals(CodeBlock.languageUsed))
      {
   	return StringFormatter.format((new CppGenerator()).translate("Closed",getConstraint()),
                                     snippet.getCode()
                                     );
      }
      return snippet.getCode();
    }
  }  
  public void setCode(String lang, String code)
  {
    snippet.setCode(lang, code);
  }
  public String getCode(String lang)
  {
    return snippet.getCode(lang);
  }
}

class ExtraCode
{
  public void appendExtraCode(String newCode)
  {
    code.add(new CodeBlock(newCode));
  }

  public void appendExtraCode(CodeBlock cb)
  {
    code.add(cb);
  }

  public String getExtraCode()
  {
    String returnCode = "";
    if(getHasCode())
    {
      for(CodeBlock cb : code)
      {
        String temp = cb.getCode();
        returnCode += (temp == null ? "" : temp);
      }
    }
    return returnCode;
  }

  public boolean getHasCode()
  {
    return code.size() > 0;
  }
}

/*
 */
class UmpleInterface
{
  public boolean hasMethod(Method comparedMethod){
    boolean isMethod=false;
    String methodName = comparedMethod.getName();
    String methodType = comparedMethod.getType();
    int numberOfParams = comparedMethod.getMethodParameters().size();
    for (Method aMethod : this.getMethods()){
      // Compare method names
      if (aMethod.getName().equals(methodName)){
      	if(aMethod.getType().equals(methodType)){  
	        // Now compare parameters
	        if (numberOfParams == aMethod.getMethodParameters().size()){
	          for (MethodParameter param: aMethod.getMethodParameters()){
	            for (MethodParameter paramToCompare: comparedMethod.getMethodParameters()){
	              if (param.getType().equals(paramToCompare.getType())){
	                isMethod=true;        
	              }
	              else{
	                return false;
	              }
	            }
	          }
	        }
	    }    
      }
    }
    return isMethod;  
  }

}

/*
 */
class UmpleElement
{
  public void appendExtraCode(String newCode)
  {
    appendExtraCode(newCode,true);
  }

  public void appendExtraCode(String newCode, boolean addNewline)
  {
    if (newCode == null) 
    { 
      return;
    }
    if (extraCode.getHasCode() && addNewline)
    {
      newCode = System.getProperty("line.separator") + newCode;
    } 
    extraCode.appendExtraCode(newCode);
  }

  public void appendExtraCode(boolean flag, CodeBlock cb)
  {
    extraCode.appendExtraCode(cb);
  }

  public boolean hasExtraCode()
  {
    return extraCode.getHasCode();
  }

  public String getExtraCode()
  {
    return extraCode.getExtraCode();
  }
}

/*
 */
class AssociationClass
{
  public AssociationClass(String name)
  {
    super(name);
  }
}

/*
 * In Umple_Code.ump: Methods for computing complex properties
 */
class UmpleClass
{

  public boolean hasMethodInTraits (Method aMethod) {
	  for (UmpleTrait uTrait : getExtendsTraits()) {
		  if (uTrait.hasCascadeMethod(aMethod,true) || uTrait.hasCascadeMethod(aMethod,false)) {
			  return true;
		  }
	}
	  return false; 
  }

  after setExtendsClass {
    if(aExtendsClass!=null&&aExtendsClass.getMethods()!=null)
    for(Method method:aExtendsClass.getMethods())
    {
      if(this.hasMethod(method))
      {
        Method aMethod = this.getMethod(method);
        
        if(aMethod.getMethodBody().getExtraCode("")==null||"".equals(aMethod.getMethodBody().getExtraCode("")))
        {
          aMethod.getMethodBody().setExtraCode("",method.getMethodBody().getExtraCode(""));
          while(aMethod.hasMethodParameters())
          {
            aMethod.removeMethodParameter(aMethod.getMethodParameter(0));
          }
          for(MethodParameter mp:method.getMethodParameters())
          {
            aMethod.addMethodParameter(mp);
          }
          if(!"".equals(aMethod.getMethodBody().getExtraCode("")))
          {
            aMethod.setIsImplemented(false);
          }
        }
      }
    }
  }

  public UmpleClass(String name)
  {
    this(name, null);
  }

  public List<StateMachine> getAllStateMachines()
  {
    ArrayList<StateMachine> all = new ArrayList<StateMachine>();
    all.addAll(getStateMachines());
    for (StateMachine sm : getStateMachines())
    {
      all.addAll(sm.getNestedStateMachines());
    }
    return all;
  }
  
  public List<TraceDirective> getAllTraceDirectives(){
    ArrayList<TraceDirective> all = new ArrayList<TraceDirective>();
    all.addAll(getTraceDirectives());
    
    for(TraceCase tc : getTraceCases())
      if( tc.getActivation() ==  true )
        for(TraceDirective td : tc.getTraceDirectives())
          all.add(td);
    
    return all;
  }

  public List<CodeInjection> getApplicableCodeInjections(String type, String method)
  {  
    ArrayList<CodeInjection> all = new ArrayList<CodeInjection>();
    if (type == null || method == null)
    {
      return all;
    }
    String formattedMethod = StringFormatter.toUnderscore(method);

    for (CodeInjection code : getCodeInjections())
    {
      if (code.getOperation() == null || !type.equals(code.getType()))
      {
        continue;
      }

      boolean isAllExcludes = true;
      TriState isMatch = new TriState(false);
      TriState isMatchOnExclude = new TriState(true);

      String[] allOperations = code.getOperation().split(",");
      for (String operation : allOperations)
      {

        boolean isNot = false;
        if (operation.startsWith("!"))
        {
          isNot = true;
          operation = operation.substring(1);
        }
        else
        {
          isAllExcludes = false;
        }
        isMatchOnExclude.setIsSet(true);

        String regexOperation = StringFormatter.toUnderscore(operation);
        regexOperation = regexOperation.replace("_*", "*");
        regexOperation = regexOperation.replace("*", ".*");
        boolean isCurrentMatch = formattedMethod.matches(regexOperation);

        if (isNot && isCurrentMatch)
        {
          isMatch.setStatus(false);
          isMatchOnExclude.setStatus(false);
        }
        else if (!isNot && isCurrentMatch)
        {
          isMatch.setStatus(true);
        }
      }

      if ((isAllExcludes && isMatchOnExclude.isTrue()) || isMatch.isTrue()) 
      {
        all.add(code);
      }
    } 

    return all;
  }

  public List<StateMachine> getStateMachines(Event e)
  { 
    List<StateMachine> allStateMachines = new ArrayList<StateMachine>();
    for (StateMachine sm : getAllStateMachines())
    {
      List<Event> allEvents = sm.getEvents();
      if (allEvents.contains(e))
      {
        allStateMachines.add(sm);
      }
    }
    return allStateMachines;
  }

  public List<Event> getEvents()
  {
    List<Event> allEvents = new ArrayList<Event>();
    for (StateMachine sm : getAllStateMachines())
    {
      allEvents.addAll(sm.getEvents());
    }

    List<Event> allUniqueEvents = new ArrayList<Event>();
    for (Event e : allEvents)
    {
      if (!allUniqueEvents.contains(e))
      {
        allUniqueEvents.add(e);
      }
    }
    return allUniqueEvents;
  }

  public Event findOrCreateEvent(String aName)
  {
    if (aName == null)
    {
      return null;
    }

    for (StateMachine sm : getStateMachines())
    {
      for (Event aEvent : sm.getAllEvents())
      {
        if (aName.equals(aEvent.getName()))
        {
          return aEvent;
        }
      }
    }
    return new Event(aName);
  }

  public StateMachine getStateMachine(String name)
  {
    for (StateMachine sm : stateMachines)
    {
      if (sm.getName().equals(name))
      {
        return sm;
      }
    }
    return null;
  }

  public void addReferencedPackage(String aNamespace)
  {
    if (indexOfNamespace(aNamespace) == -1 && !aNamespace.equals(getPackageName()))
    {
      addNamespace(aNamespace);
    }
  }

  public AssociationVariable getAssociationVariable(String name)
  {
    for (AssociationVariable av : associationVariables)
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  public AssociationVariable getAssociationVariableFor(UmpleClass uClass)
  {
    for (AssociationVariable av : associationVariables)
    {
      if (av.getType().equals(uClass.getName()))
      {
        return av;
      }
    }
    return null;
  }

  public boolean hasImplementedMethodIncludingWithinParentClasses(Method comparedMethod) {
    Method aMethod = getMethod(comparedMethod);
    if(aMethod!=null&&!aMethod.isIsAbstract()){
      return true;
    }
    else if(getExtendsClass()!=null&&getExtendsClass().hasImplementedMethodIncludingWithinParentClasses(comparedMethod)){
      return true;
    }
    return false;
  }

  public boolean hasMethod(Method comparedMethod){
    String methodName = comparedMethod.getName();
    String methodType = comparedMethod.getType();
    int numberOfParams = comparedMethod.getMethodParameters().size();
    for (Method aMethod : this.getMethods()){
      // Compare method names
      if (aMethod.getName().equals(methodName)){  
    	  if(aMethod.getType().equals(methodType)){
	        // Now compare parameters
	        if (numberOfParams == aMethod.getMethodParameters().size())
	        {
	          boolean allSame = true;
	          for (int i = 0; i < numberOfParams; i++)
	          {
	            if(!aMethod.getMethodParameter(i).getType().equals(comparedMethod.getMethodParameter(i).getType()))
	            {
	              allSame = false;
	              break;
	            }
	          }
	          if(allSame)
	          {
	            return true;
	          }
	        }
    	  }  
      }
    }
    return false;  
  }
  
  public Method getMethod(Method comparedMethod){
    String methodName = comparedMethod.getName();
    int numberOfParams = comparedMethod.getMethodParameters().size();
    for (Method aMethod : this.getMethods()){
      // Compare method names
      if (aMethod.getName().equals(methodName)){  
        // Now compare parameters
        if (numberOfParams == aMethod.getMethodParameters().size())
        {
          boolean allSame = true;
          for (int i = 0; i < numberOfParams; i++)
          {
            if(!aMethod.getMethodParameter(i).getType().equals(comparedMethod.getMethodParameter(i).getType()))
            {
              allSame = false;
              break;
            }
          }
          if(allSame)
          {
            return aMethod;
          }
        }
      }
    }
    return null;  
  }

  public Attribute getAttribute(String name)
  {
    for (Attribute av : attributes)
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  public boolean isRoot()
  {
    return extendsClass == null;
  }

  protected GeneratedClass gClass = null;
  public GeneratedClass getGeneratedClass()
  {
    return gClass;
  }

  public GeneratedClass createGeneratedClass(UmpleModel model)
  {
    gClass = new GeneratedClass(model, this);
    if (getExtendsClass() != null)
    {
      gClass.setParentClass(getExtendsClass().getGeneratedClass());
    }
    return getGeneratedClass();
  }

  public boolean isAttributeClass()
  {
    for (AssociationVariable association : getAssociationVariables())
    {
      if (association.getIsNavigable())
      {
        return false;
      }
    }
    return true;
  }
  
  /* @return true if this class is immutable, either because it has the "immutable" modifier or 
   * because an ancestor class is immutable; false if this class neither has the "immutable" modifier 
   * nor an immutable ancestor.
   */
  public boolean isImmutable()
   {
     return (iAmImmutable || ancestorIsImmutable);
  }
    
  public boolean setImmutable()
  {
    boolean wasSet = false;
    if (extendsClass != null && !ancestorIsImmutable) { return wasSet; }
    
    if (propagateImmutabilityToAllRelationships(true)) 
    { 
      iAmImmutable = true;
      wasSet = true;
    }
    return wasSet;
  }
  
  private boolean propagateImmutabilityToAllRelationships(boolean isImmutable)
  {
    if (isImmutable)
    {
      if (this.hasStateMachines()) { return false; }

      for (AssociationVariable av : associationVariables)
      {
        if (!immutabilityAssociationRulesSatisfied(av, true)) { return false; }
      }
    }
    
    return notifySubclassesAncestorImmutable(isImmutable);
  }
  
  private boolean notifySubclassesAncestorImmutable(boolean isImmutable)
  {
    boolean notified = true;
    List<UmpleClass> wereSet = new ArrayList<UmpleClass>();
    for (UmpleClass subclass : getSubclasses())
    {
      notified = subclass.setAncestorIsImmutable(isImmutable);
      if (!notified)
      {
        for (UmpleClass wasSet : wereSet)
        {
          wasSet.setAncestorIsImmutable(!isImmutable);
        }
        return notified;
      }
    }
    return notified;
  }
  
  protected boolean setAncestorIsImmutable(boolean isImmutable)
  {
    if (iAmImmutable)
    {
      ancestorIsImmutable = isImmutable;
      return true;
    }
    else
    {
      boolean success = propagateImmutabilityToAllRelationships(isImmutable);
      if (success) { ancestorIsImmutable = isImmutable; }
      return success;
    }
  }
  
  private boolean enforceImmutabilityInheritanceRules(UmpleClass newSuperClass)
  {
    // A subclass may not be immutable if the superclass is not immutable
    if (iAmImmutable && newSuperClass != null && !newSuperClass.isImmutable()) { return false; }
    boolean ancestorImmutable = (newSuperClass == null) ? false : newSuperClass.isImmutable();
    return setAncestorIsImmutable(ancestorImmutable);
  }

  protected static boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, UmpleClass myClass, boolean myClassImmutable, 
      AssociationVariable yourAV, UmpleClass yourClass, boolean yourClassImmutable)
  {
    boolean satisfied = false;
    if (myAV == null || yourAV == null)
    {
      satisfied = true;
    }
    else if (!myClassImmutable && !yourClassImmutable && !"immutable".equals(myAV.getModifier()) && !"immutable".equals(yourAV.getModifier()))
    {
      satisfied = true;
    } 
    else if (myAV.getIsNavigable() && yourAV.getIsNavigable())
    {
      //satisfied = false;
    }
    else if (myClass == null && yourClass == null)
    {
      satisfied = true;
    }
    else if (!yourAV.getIsNavigable() && (yourClass == null || yourClassImmutable))
    {
      if (yourClass != null && yourClass == myClass && myAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    else if (!myAV.getIsNavigable() && (myClass == null || myClassImmutable))
    {
      if (myClass != null && yourClass == myClass && yourAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    return satisfied;
  }

  protected boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, boolean myClassImmutable)
  {
    AssociationVariable relatedAV = myAV.getRelatedAssociation();
    UmpleClass relatedClass = (relatedAV == null) ? null : relatedAV.getUmpleClass();
    boolean relatedClassImmutable = (relatedClass == null) ? false : ((relatedClass == this) ? myClassImmutable : relatedClass.isImmutable());

    return immutabilityAssociationRulesSatisfied(myAV, this, myClassImmutable, relatedAV, relatedClass, relatedClassImmutable);
  }
  
  
  public boolean deleteAttribute(Attribute aAttribute)
  {
    boolean wasRemoved = false;
    //Unable to remove aAttribute, as it must always have a umpleClass
    if (this.equals(aAttribute.getUmpleClass()))
    {
      attributes.remove(aAttribute);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  
  

}

/*
 */
class UmpleVariable
{
  public String getUpperCaseName()
  {
    if (name == null || name.length() == 0)
    {
      return name;
    }
    else if (name.length() == 1)
    {
      return name.toUpperCase();
    }
    else
    {
      return name.toUpperCase().charAt(0) + name.substring(1);
    }
  }

  public boolean isImmutable()
  {
    return "immutable".equals(modifier);
  }
  
  public String normalizeValue(String aType, String aValue)
  {
    if (aType == null || aValue == null || aValue.length() == 0)
    {
      return aValue;
    }
    else if (("Float".equals(aType)) && ("f".equals(aValue.substring(aValue.length()-1))))
    {
      return aValue.substring(0, aValue.length()-1);
    }
    else
    {
      return aValue;
    }
  }
}

/*
 */
class Attribute
{
  public Attribute(Attribute another){
  	super(another.getName(), another.getType(), another.getModifier(), another.getValue());
  	isAutounique = another.getIsAutounique() ;
	isUnique = another.getIsUnique();
	isList = another.getIsList();
	isDerived = another.getIsDerived();
	codeblock = another.getCodeblock();
	isLazy = another.getIsLazy();
	//Attribute Associations
	comments = another.getComments();
	position = another.getPosition();
	endPosition = another.getEndPosition();
	umpleClass = another.getUmpleClass();
	umpleTrait = another.getUmpleTrait();
	traceRecords = another.getTraceRecords();
  }
  	
  public boolean isConstant()
  {
    return "const".equals(getModifier());
  }  

  public boolean isPrimitive()
  {
    return getType() == null || "String".equals(getType()) || "Integer".equals(getType()) || "Double".equals(getType()) || "Boolean".equals(getType()) || "Date".equals(getType()) || "Time".equals(getType());
  }


  public boolean isImmutable()
  {
    boolean varIsImmutable = super.isImmutable();
    boolean classIsImmutable = (this.getUmpleClass() == null) ? false : getUmpleClass().isImmutable();

    return (varIsImmutable || classIsImmutable);
  }
  
  public String getValue()
  {
    String possibleValue = codeblock.getCode(); 
    return "".equals(possibleValue) ? super.getValue() : possibleValue;
  }

  public boolean setType(String aType)
  {
    boolean answer = super.setType(aType);
    setValue(getValue());
    return answer;
  }

  public boolean setValue(String aValue)
  {
    aValue = normalizeValue(getType(),aValue);
    codeblock.setCode(aValue);
    return super.setValue(aValue);
  }

  public boolean setValue(String lang, String code)
  {
    codeblock.setCode(lang,code);
    return true;
  }

  public String getFullType()
  {
    return this.getType() + (this.getIsList() ? "[]" : "");
  }
  
}

/*
 */
class Association
{
   public  Association(Association another){
    //Association Attributes
	  this.name = another.getName();
	  this.isLeftNavigable = another.getIsLeftNavigable();
	  this.isRightNavigable = another.getIsRightNavigable();
	  this.positions = new ArrayList<Coordinate>();
	  for (Coordinate coordinate : another.getPositions()) {
		this.positions.add(coordinate);
	  }  
	  this.tokenPosition = another.getTokenPosition();
	  this.tokenEndPosition = another.getTokenEndPosition();
	  this.immutable = another.immutable;
	
	  //Association Associations
	  this.ends = new ArrayList<AssociationEnd>();
	  for (AssociationEnd associationEnd : another.getEnds()) {
		  this.ends.add(new AssociationEnd(associationEnd));
	  }
	  this.associationTraceItems = new ArrayList<AssociationTraceItem>();
	  for (AssociationTraceItem associationTraceItems : another.getAssociationTraceItems()) {
		  this.associationTraceItems.add(associationTraceItems);
	  }
  }
  
  public void setLeftAndRight()
  {
    String name = this.getName();

    int underscore = name.indexOf("__");
    String nameOne = name.substring(0,underscore);
    String nameTwo = name.substring(underscore + "__".length(), name.length());

    if (nameOne.compareTo(nameTwo) > 0)
    {

    }

  }

  public int whoIsInvalid()
  {
    if (!getIsLeftNavigable() || !getIsRightNavigable())
    {
      return -1;
    }

    if (getEnd(0).getClassName().equals(getEnd(1).getClassName()))
    {
      if (getEnd(0).getMultiplicity().getLowerBound() != 0)
      {
        return 0;
      }
      else if (getEnd(1).getMultiplicity().getLowerBound() != 0)
      {
        return 1;
      }
    }
    return -1;
  }

  public boolean isValid()
  {
    return whoIsInvalid() == -1;
  }

  public String getArrowString()
  {
    String arrow = "--";
    if (getIsLeftNavigable() && !getIsRightNavigable())
    {
      arrow = "<-";
    }
    else if (!getIsLeftNavigable() && getIsRightNavigable())
    {
      arrow = "->";
    }
    else if (!getIsLeftNavigable() && !getIsRightNavigable())
    {
      arrow = "><";
    }
    return arrow;
  }

  public String toGenericString()
  {
    String leftSide = getEnd(0).toGenericString();
    String rightSide = getEnd(1).toGenericString();


    if (leftSide.equals("n") && rightSide.equals("n") && !getEnd(0).toSimpleString().equals(getEnd(1).toSimpleString()))
    {
      return cruise.umple.util.StringFormatter.format("n {0} m",getArrowString());
    }
    else
    {
      return cruise.umple.util.StringFormatter.format("{0} {1} {2}",leftSide,getArrowString(),rightSide);
    }
  }

  public String deriveName()
  {
    AssociationEnd firstEnd = this.getEnd(0);
    AssociationEnd secondEnd = this.getEnd(1);

    String firstClassName = firstEnd.getClassName();
    String secondClassName = secondEnd.getClassName();

    String firstRole = firstEnd.getDisplayRoleName().equals("") ? "" : ":" + firstEnd.getDisplayRoleName();
    String secondRole = secondEnd.getDisplayRoleName().equals("") ? "" : ":" + secondEnd.getDisplayRoleName();

    if (firstClassName.compareTo(secondClassName) <= 0)
    {
      return firstClassName + firstRole + "__" + secondClassName + secondRole;
    }
    else
    {
      return secondClassName + secondRole + "__" + firstClassName + firstRole;
    }
  }
  
  public void setImmutable()
  {
    this.immutable = true;
  }
  
  public boolean isImmutable()
  {
    return this.immutable;
  }
}

class ConstraintVariable
{
  after setStateMachine { setIsStateMachine(aStateMachine!=null); setType("STATEMACHINE"); }
  after setState { setIsState(aState!=null); setType("STATE"); }
  UmpleVariable getAttribute(UmpleClassifier uClassifier){
	if(!getIsAttribute()) {
      return null;
    }
    if(uClassifier==null){
    	return null;
    }
    UmpleVariable uv;
    if (uClassifier instanceof UmpleClass) {
    	 uv= ((UmpleClass)(uClassifier)).getAttribute(this.getValue());
    } else {
    	uv = ((UmpleTrait)(uClassifier)).getAttribute(this.getValue());
    }
    
    if(uv!=null){
      setFoundAttribute(uv);
      isAssociation = ((Attribute)uv).getIsList();
      return uv;
    }
    else
    {
      if (uClassifier instanceof UmpleClass) {
    	  uv = ((UmpleClass)(uClassifier)).getAssociationVariable(this.getValue());
      } else {
    	  uv = ((UmpleTrait)(uClassifier)).getAssociationVariable(this.getValue());
      }	
      
      setFoundAttribute(uv);
      isAssociation = uv!=null;
      return uv;
    }
  }
  
}

class Constraint
{
  public String toString()
  {
    if(numberOfExpressions()==0)
    {
      return "";
    }
    StringBuilder out = new StringBuilder();
    List<ConstraintVariable> toAdd = new ArrayList<ConstraintVariable>();
    for(int m = 0; m < numberOfExpressions(); m++)
    {
      if(getExpression(m).getIsAttribute()&&!toAdd.contains(getExpression(m)))
      {
        toAdd.add(getExpression(m));
      }
    }
    if(toAdd.size()==0)
    {
      return "";
    }
    else if(toAdd.size()==1)
    {
      return toAdd.get(0).getValue();
    }
    else
    {      
      out.append(toAdd.get(0).getValue());
      for(int m = 1; m < toAdd.size()-1; ++m)
      {
        out.append(", ");
        out.append(toAdd.get(m).getValue());
      }
      out.append(" and ");
      out.append(toAdd.get(toAdd.size()-1).getValue());
    }      
    return out.toString();
  }
  
  void mergeWith(Constraint constraint)
  {
    boolean first = true;
    if(numberOfExpressions()>0)
    {
      first = false;
      if(getNegated()&&!constraint.getNegated())
      {
        addExpression(new ConstraintVariable("OPERATOR","||"));
      }
      else 
      {
        addExpression(new ConstraintVariable("OPERATOR","&&"));
      }
    }
    if(constraint.getNegated())
    {
      addExpression(new ConstraintVariable("OPERATOR","!"));
    }  
    if(!first)
    {
      addExpression(new ConstraintVariable("SYNTAX","("));
    }
    for(ConstraintVariable cv: constraint.getExpressions())
    {
      addExpression(cv);
    }
    if(!first)
    {
      addExpression(new ConstraintVariable("SYNTAX",")"));
    }
  }
  
  public boolean equals(Object object)
  {
    if(object==null)
    {
      return false;
    }
    else
    {
      Constraint constraint = (Constraint)object;
      int size = constraint.numberOfExpressions();
      if(numberOfExpressions()!=size)
      {
        return false;
      }
      for(int i=0;i<size;i++)
      {
        if(!getExpression(i).equals(constraint.getExpression(i)))
        {
          return false;
        }
      }
    }
    return true;
  }
}

/*
 * In Umple_Code.ump: Methods for computing compound properties
 */
class AssociationEnd
{

  public AssociationEnd(AssociationEnd another) {
  	//AssociationEnd Attributes
  	this.roleName = another.getRoleName();
  	this.className = another.getClassName();
  	this.modifier = another.getModifier();
  	this.referenceToClassName = another.getReferenceToClassName();
  	this.multiplicity = another.getMultiplicity();
  	this.isDefaultRoleName = another.getIsDefaultRoleName();
  	this.priority = another.getPriority();
	
  	//AssociationEnd Associations	
  	this.association = another.getAssociation();
	
  	//Helper Variables
  	this.cachedHashCode = another.cachedHashCode;
  	this.canSetMultiplicity = another.canSetMultiplicity;
  	this.canSetRoleName = another.canSetRoleName;
	this.canSetClassName = another.canSetClassName;
	this.canSetModifier = another.canSetModifier;
	this.canSetReferenceToClassName = another.canSetReferenceToClassName;	
  }
  private static int MULT_MANY = -1;

  public boolean isNavigable()
  {
    return !getModifier().toLowerCase().equals("nonnavigable");
  }  

  public String getLowerBoundString()
  {
    return getMultiplicity().getLowerBound() == -1 ? "*" : getMultiplicity().getLowerBound() + "";
  }

  public String getUpperBoundString()
  {
    return getMultiplicity().getUpperBound() == -1 ? "*" : getMultiplicity().getUpperBound() + "";
  }

  public String getDisplayRoleName()
  {
    return isDefaultRoleName ? "" : getRoleName();
  }

  public String toSimpleString()
  {
    if (getMultiplicity().getLowerBound() == 0 && getMultiplicity().getUpperBound() == MULT_MANY)
    {
      return formatEnd(getMultiplicity().getUpperBound());
    }
    else if (getMultiplicity().getLowerBound() == MULT_MANY && getMultiplicity().getUpperBound() == MULT_MANY)
    {
      return formatEnd(getMultiplicity().getLowerBound()) + ".." + formatEnd(getMultiplicity().getUpperBound());
    }
    else if (getMultiplicity().getLowerBound() == getMultiplicity().getUpperBound())
    {
      return formatEnd(getMultiplicity().getLowerBound());
    }
    else
    {
      return formatEnd(getMultiplicity().getLowerBound()) + ".." + formatEnd(getMultiplicity().getUpperBound());
    }
  }

  public String toGenericString()
  {
    if (getMultiplicity().getLowerBound() == 0 && getMultiplicity().getUpperBound() == MULT_MANY)
    {
      return formatEnd(getMultiplicity().getUpperBound());
    }
    else if (getMultiplicity().getLowerBound() == MULT_MANY && getMultiplicity().getUpperBound() == MULT_MANY)
    {
      return formatEnd(getMultiplicity().getLowerBound()) + ".." + formatEnd(getMultiplicity().getUpperBound());
    }
    else if (getMultiplicity().getLowerBound() == getMultiplicity().getUpperBound())
    {
      return formatGenericEnd(getMultiplicity().getLowerBound(),"n");
    }
    else if (getMultiplicity().getLowerBound() == 0 || getMultiplicity().getLowerBound() == 1)
    {
      return getMultiplicity().getLowerBound() + ".." + formatGenericEnd(getMultiplicity().getUpperBound(),"n");
    }
    else
    {
      return formatGenericEnd(getMultiplicity().getLowerBound(),"n") + ".." + formatGenericEnd(getMultiplicity().getUpperBound(),"m");
    }
  }

  public String toString()
  {
    String asText = "";

    if (!getModifier().equals("internal"))
    {
      asText += getModifier() + " " + asText;
    }
    asText += toSimpleString();

    if (getRoleName().length() > 0)
    {
      asText += " [" + roleName + "]";
    }

    if (getClassName().length() > 0)
    {
      asText += " " + className;
    }

    if (getReferenceToClassName().length() > 0)
    {
      asText += " -- " + referenceToClassName;
    }

    return asText;
  }

  private String formatEnd(int aValue)
  {
    return aValue == MULT_MANY ? "*" : aValue + "";
  }

  private String formatGenericEnd(int aValue, String defaultIfNotOneOrMany)
  {

    if (aValue == MULT_MANY)
    {
      return "*";
    }
    else if (aValue == 0 || aValue == 1)
    {
      return aValue + "";
    }
    else
    {
      return defaultIfNotOneOrMany;
    }
  }  

}

/*
 * In Umple_Code.ump: Methods for testing various complex properties
 */
class AssociationVariable
{
  public AssociationVariable(AssociationVariable another){
	  super(another.getName(), another.getType(),another.getModifier(), another.getValue());
	  //AssociationVariable Attributes
	  this.multiplicity = another.getMultiplicity();
	  this.isNavigable = another.getIsNavigable();
	  this.priority  = another.getPriority();

	  //AssociationVariable Associations
	  this.relatedAssociation = another.getRelatedAssociation();
	  this.comments = new ArrayList<Comment>();
	  for (Comment comment : another.getComments()) {
		  this.comments.add(comment);
	  }
	
	  this.umpleClass = another.getUmpleClass();
	  this.umpleTrait = another.getUmpleTrait();
	  this.associationTraceItems = new ArrayList<AssociationTraceItem>();
	  for (AssociationTraceItem associationTraceItem : another.getAssociationTraceItems()) {
		  this.associationTraceItems.add(associationTraceItem);
	  }
	  //Helper Variables
	  this.canSetIsNavigable = another.canSetIsNavigable;
  }	

  public boolean isReflexive()
  {
    return getRelatedAssociation() != null && getType().equals(getRelatedAssociation().getType());
  }

  public boolean isSymmetricReflexive()
  {
    return getRelatedAssociation() != null && "symmetricreflexive".equals(getModifier());
  }

  public void configureRelatedAssociation(AssociationVariable newRelatedAssociation)
  {
    if (newRelatedAssociation == null || !getType().equals(newRelatedAssociation.getType()))
    {
      setRelatedAssociation(newRelatedAssociation);
    }
    else
    {
      multiplicity.minimizeRange(newRelatedAssociation.getMultiplicity());
      setRelatedAssociation(this);
    }
  }

  public static int min(int first, int second)
  {
    return first == -1 ? second : second == -1 ? first : Math.min(first, second);
  }

  public static int max(int first, int second)
  {
    return first == -1 ? first : second == -1 ? second : Math.max(first, second);
  }

  public boolean isMany()
  {
    return multiplicity.getUpperBound() == -1 || multiplicity.getUpperBound() > 1;
  }

  public boolean isOptionalN()
  {
    return multiplicity.getLowerBound() == 0 && multiplicity.getUpperBound() > 1;
  }

  public boolean isOne()
  {
    return multiplicity.getUpperBound() == 1;
  }

  public boolean isOnlyOne()
  {
    return multiplicity.getUpperBound() == 1 && multiplicity.getLowerBound() == 1;
  }

  public boolean isOptionalOne()
  {
    return multiplicity.getUpperBound() == 1 && multiplicity.getLowerBound() == 0;
  }

  public boolean isOptionalMany()
  {
    return multiplicity.getLowerBound() == 0 && isMany();
  }
  
  public boolean isUpperBounded()
  {
    return multiplicity.getUpperBound() >= 0;
  }

  public boolean isN()
  {
    return multiplicity.getLowerBound() > 1 && multiplicity.getLowerBound() == multiplicity.getUpperBound();
  }

  public boolean isMN()
  {
    return multiplicity.getLowerBound() > 0 && (multiplicity.getUpperBound() > multiplicity.getLowerBound() || multiplicity.getUpperBound() == -1);
  }

  public boolean isMStar()
  {
    return multiplicity.getLowerBound() > 0 && multiplicity.getUpperBound() == -1;
  }

  public boolean isStar()
  {
    return multiplicity.getUpperBound() == -1;
  }

  public boolean isMandatory()
  {
    return multiplicity.getLowerBound() > 0;
  }

  public boolean isMandatoryOne()
  {
    return multiplicity.getLowerBound() == 1 && multiplicity.getUpperBound() == 1;
  }

  public boolean isMandatoryMany()
  {
    return multiplicity.getLowerBound() > 0 && isMany();
  }

  public boolean isImmutable()
  {
    AssociationVariable related = getRelatedAssociation();
    Boolean relatedAssocIsImmutable = (related == null) ? false : "immutable".equals(related.getModifier());

    Boolean myUmpleClassIsImmutable = 
      (getIsNavigable() && getUmpleClass() != null) ? getUmpleClass().isImmutable() : false;
    Boolean yourUmpleClassIsImmutable = 
      (related != null && related.getIsNavigable() && related.getUmpleClass() != null) ? related.getUmpleClass().isImmutable() : false;

    return (super.isImmutable() || relatedAssocIsImmutable 
        || myUmpleClassIsImmutable || yourUmpleClassIsImmutable);
  }

  public boolean setImmutable()
  {
    boolean wasSet = false;
    if (canBeImmutable())
    {
      setModifier("immutable");
      wasSet = true;
    }
    return wasSet;
  }

  public boolean isSorted()
  {
    return !priority.equals("");
  }

  private boolean canBeImmutable()
  {
    AssociationVariable related = getRelatedAssociation();
    if (related == null) { return true; }

    boolean canBe = true;
    if (getIsNavigable() && related.getIsNavigable())
    {
      canBe = false;
    }
    else if (related.getIsNavigable() && (umpleClass != null) && !umpleClass.isImmutable())
    {
      canBe = false;
    }
    else if (getIsNavigable() && (related.getUmpleClass() != null) && !related.getUmpleClass().isImmutable())
    {
      canBe = false;
    }
    return canBe;
  }

  private boolean canBeRelatedAssociation(AssociationVariable related)
  {
    if (related == null)
    {
      return true;
    }
    Boolean myUmpleClassIsImmutable = (getUmpleClass() != null) ? getUmpleClass().isImmutable() : false;
    Boolean yourUmpleClassIsImmutable = (related.getUmpleClass() != null) ? related.getUmpleClass().isImmutable() : false;

    return UmpleClass.immutabilityAssociationRulesSatisfied(this, umpleClass, myUmpleClassIsImmutable, 
        related, related.getUmpleClass(), yourUmpleClassIsImmutable);
  }
  
}

/*
 * In Umple_Code.ump: Methods for querying various propertiies of a Multiplicit
 */
class Multiplicity
{

  public void setRange(String lowerBound, String upperBound)
  {
    minimum = lowerBound;
    maximum = upperBound;
  }

  public String getRange()
  {
    String lowerBound = getLowerBound() == -1 ? "*" : getLowerBound() + ""; 
    String upperBound = getUpperBound() == -1 ? "*" : getUpperBound() + "";
    return StringFormatter.format("[{0},{1}]",lowerBound,upperBound);
  }

  public String[] getRangeParts()
  {
    String lowerBound = getLowerBound() == -1 ? "*" : getLowerBound() + ""; 
    String upperBound = getUpperBound() == -1 ? "*" : getUpperBound() + "";
    return new String[] { lowerBound, upperBound };
  }

  public boolean isValid()
  {
    if ("*".equals(getMinimum()))
    {
      return false;
    }

    if ("-1".equals(getMinimum()) || "-1".equals(getMaximum()) || "-1".equals(getBound()))
    {
      return false;
    }

    if (getLowerBound() < -1 || getUpperBound() < -1)
    {
      return false;
    }
    
    // Fix for issue 292
    if (getUpperBound() == 0)
    {
      return false;
    }


    if (getLowerBound() > getUpperBound() && !isUpperBoundMany())
    {
      return false;
    }

    return true;
  }

  public void minimizeRange(Multiplicity compareTo)
  {
    if (compareTo.getLowerBound() > getLowerBound() && compareTo.minimum != null)
    {
      minimum = compareTo.minimum;
    }
    if (compareTo.getUpperBound() < getUpperBound() && compareTo.maximum != null && compareTo.getUpperBound() != -1)
    {
      maximum = compareTo.maximum;
    }
  }

  public int getLowerBound()
  {
    if (getBound() != null)
    {
      return parseInt(getBound(),0);
    }
    else
    {
      return parseInt(getMinimum(),-1);
    }
  }

  public int getUpperBound()
  {
    if (getBound() != null)
    {
      return parseInt(getBound(),-1);
    }
    else
    {
      return parseInt(getMaximum(),-1);
    }
  }

  public boolean isLowerBoundMany()
  {
    return getLowerBound() == -1;
  }

  public boolean isUpperBoundMany()
  {
    return getUpperBound() == -1;
  }

  public boolean isLowerBoundNumeric()
  {
    return getLowerBound() >= -1;
  }

  public boolean isUpperBoundNumeric()
  {
    return getUpperBound() >= -1;
  }

  public boolean isMany()
  {
    return getUpperBound() > 1 || getUpperBound() == -1;
  }

  public boolean isOne()
  {
    return getUpperBound() == 1;
  }

  private int parseInt(String input, int defaultIfStar)
  {
    try
    {
      if ("*".equals(input))
      {
        return defaultIfStar;
      }
      else
      {
        return Integer.parseInt(input);
      }
    }
    catch(Exception e)
    {
      return -2;
    }
  }
}

/*
 */
class GeneratedElement
{

  private Map<String, String> lookups = new HashMap<String, String>();
  private Map<String, List<String>> multiLookups = new HashMap<String,List<String>>();

  public void setLookup(String aKey, String aValue)
  {
    lookups.put(aKey, aValue);
  }

  public String getLookup(String aKey)
  {
    if (aKey == null)
    {
      return null;
    }
    else
    {
      return lookups.get(aKey);  
    }
  }

  public boolean addMultiLookup(String aKey, String aValue)
  {
    List<String> oldList = null;
    if (multiLookups.containsKey(aKey))
    {
      oldList = multiLookups.get(aKey);
    }
    else
    {
      oldList = new ArrayList<String>();
    }

    if (aValue == null || "".equals(aValue) || oldList.contains(aValue))
    {
      return false;
    }

    oldList.add(aValue);
    multiLookups.put(aKey, oldList);
    return true;
  }

  public String[] getMultiLookup(String aKey)
  {
    if (aKey == null || !multiLookups.containsKey(aKey))
    {
      return new String[0];
    }
    else
    {
      List<String> list = multiLookups.get(aKey);

      return list.toArray(new String[list.size()]);
    }
  }

  public String toString()
  {
    String answer = "<<";
    for (String aKey : lookups.keySet())
    {
      answer += "[" + aKey + ":" + lookups.get(aKey) + "]";
    }    
    answer += ">>";
    return answer;
  }
}

/*
 */
class Point
{

  public static Point create(int n)
  {
    int p = (int)Math.sqrt(n) + 1;
    if (n - (p-2)*p <= p)
    {
      return new Point(n - (p-2)*p, p);
    }
    else
    {
      return new Point(p, n - (p-1) * p);
    }
  }

  public String toString()
  {
    return "(" + getX() + "," + getY() + ")";
  }
}

/*
 */
class Coordinate
{

  public Point getTopLeft()
  {
    return new Point(x,y);
  }

  public Point getTopRight()
  {
    return new Point(x+width,y);
  }

  public Point getBottomLeft()
  {
    return new Point(x,y+height);
  }

  public Point getBottomRight()
  {
    return new Point(x+width,y+height);
  }

  public Point getTopMiddle()
  {
    return new Point(x+width/2,y);
  }

  public Point getBottomMiddle()
  {
    return new Point(x+width/2,y+height);
  }

  public Point getRightMiddle()
  {
    return new Point(x+width,y+height/2);
  }

  public Point getLeftMiddle()
  {
    return new Point(x,y+height/2);
  }

  public String whereIs(Coordinate neighbour)
  {
    int topDeltaY = getTopMiddle().getY() - neighbour.getBottomMiddle().getY();
    int topDeltaX = getTopMiddle().getX() - neighbour.getBottomMiddle().getX();

    int bottomDeltaY = neighbour.getTopMiddle().getY() - getBottomMiddle().getY();
    int bottomDeltaX = getBottomMiddle().getX() - neighbour.getTopMiddle().getX(); 

    if (topDeltaY > 0 && Math.abs(topDeltaY) > Math.abs(topDeltaX))
    {
      return "top";
    }
    else if (bottomDeltaY > 0 && Math.abs(bottomDeltaY) > Math.abs(bottomDeltaX))
    {
      return "bottom";
    }
    else if (neighbour.getX() < getX())
    {
      return "left";
    }
    else
    {
      return "right";
    }
  }

  public int distanceTo(Coordinate other)
  {
    int a = other.getX() - getX();
    int b = other.getY() - getY();
    int c = (int) Math.round(Math.sqrt(Math.pow(a,2) + Math.pow(b,2)));
    return c; 
  }

  public String toString()
  {
    return "(" + getX() + "," + getY() + "," + getWidth() + "," + getHeight() + ")";
  }

  private void updateStatus()
  {
    if (x == -1 && y == -1 && width == -1 && height == -1)
    {
      setStatus(Status.Undefined);
    }
    else 
    {
      setStatus(Status.Explicit);
    }
  }
}

/*
 */
class Comment
{
  Boolean isInline = true;

  /**
   * Used to take a comment and process it into a format appropriate for displaying in generated code.
   * 
   * For example, you may want a bunch of inline comments put together and displayed as Javadoc.  This accomplishes that (among others).
   * 
   * @param type Indicates the type of comment which determines how the comments are formatted.  The types are: Hash, Javadoc, Attribute Javadoc, Association Javadoc, Method Javadoc, RubyMultiline, RubyMultiline Internal and Multiline.  Defaults to "//" if not specified.
   * @param allComments A list of comments to be processed and formatted all together as one.
   * 
   * @return The processed/formatted comment appropriate for use in generated code output.
   */
  public static String format(String type,List<Comment> allComments)
  {
    //String commentDelimiter = type == "Hash" ? "# " : (type == "Javadoc") ? " * " : (type == "Attribute Javadoc") ? "   * " : (type == "Association Javadoc") ? "   * " : (type == "Method Javadoc") ? "   * " : (type == "RubyMultiline") ? "  " : (type == "Multiline") ? "" : "// ";

    String commentDelimiter;

    // Set the comment delimiter based on the type of the comment. (ex. For Javadoc prepend "*" before every comment line)
    if (type == "Hash")
    {
      commentDelimiter = "# ";
    }
    else if (type == "Javadoc")
    {
      commentDelimiter = " * ";
    }
    else if (type == "Attribute Javadoc")
    {
      commentDelimiter = "   * ";
    }
    else if (type == "Association Javadoc")
    {
      commentDelimiter = "   * ";
    }
    else if (type == "Method Javadoc")
    {
      commentDelimiter = "   * ";
    }
    else if (type == "RubyMultiline")
    {
      commentDelimiter = "";
    }
    else if (type == "RubyMultiline Internal")
    {
      commentDelimiter = "  ";
    }
    else if (type == "Multiline")
    {
      commentDelimiter = "";
    }
    else
    {
      commentDelimiter = "// ";
    }

    if (allComments.size() == 0)
    {
      return null;
    }

    String output = "";

    for (Comment c : allComments)
    {
      if (type == "Javadoc" || type == "Attribute Javadoc" || type == "Association Javadoc" || type == "Method Javadoc" || type == "RubyMultiline" || type == "RubyMultiline Internal")
      {
        int startIndex = 0;

        // Go through each letter of the current comment to find start of content.
        for (int i = 0; i < c.getText().length(); i++)
        {
          char letter = c.getText().charAt(i);

          // Remove these letters until the actual content is found in the line.
          if (letter == ' ' || letter == '\t' || letter == '*')
          {
            startIndex++;
          }
          // Comment content found, set comment to start here.
          else
          {
            c.setText(c.getText().substring(startIndex));
            break;
          }
        }

        // Special case where the comment line had no content (only spaces, tabs or asterisks).
        if (startIndex == c.getText().length())
        {
          c.setText(c.getText().substring(startIndex));
        }
      }
      output += commentDelimiter + c.getText() + "\n"; 
    }

    // Finalize the comment based on what type it was. (ex. For Javadoc place the "/**" and "*/" around the comment)
    if (type == "Javadoc")
    {
      output = "/**\n" + output + " */";
    }
    else if (type == "Attribute Javadoc")
    {
      output = "  /**\n" + output + "   */";
    }
    else if (type == "Association Javadoc")
    {
      output = "  /**\n" + output + "   */";
    }
    else if (type == "Method Javadoc")
    {
      output = "  /**\n" + output + "   */";
    }
    else if (type == "RubyMultiline")
    {
      output = "=begin\n" + output + "=end";
    }
    else if (type == "RubyMultiline Internal")
    {
      output = "  =begin\n" + output + "  =end";
    }
    else if (type == "Multiline")
    {
      output = "/*\n" + output + "*/";
    }

    return output.trim();
  }
}


class GeneralTPApplied {
	Map<String,String> parameterMapping = new HashMap<String,String>();
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void ApplyTypeParametersToMethod(Method newMethod){   
	for (String strType : this.getParameterMapping().keySet()) {
		String newName = this.getParameterMapping().get(strType);
		if (newMethod.getType().equals(strType)){
			newMethod.setType(newName);
		}
		for (int i = 0; i < newMethod.numberOfMethodParameters(); i++) {
            if(newMethod.getMethodParameter(i).getType().equals(strType)){
            	newMethod.getMethodParameter(i).setType(newName);
            }
	    }
	}
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	
	public GeneralTPApplied(GeneralTPApplied another) {
	  this.parameterMapping = another.parameterMapping;
	  this.inheritanceName = another.inheritanceName;
	  methodTemplateSignatures = new ArrayList<MethodTemplateSignature>();
	  for (MethodTemplateSignature mtSignature : another.getMethodTemplateSignatures()) {
		  methodTemplateSignatures.add(new MethodTemplateSignature(mtSignature));
	  } 
  	}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	
	boolean hasMethodTemplateSignature(MethodTemplateSignature inMTSignature) {
		for (MethodTemplateSignature mTSignature : getMethodTemplateSignatures()) {
			if (compareTwoMethdos(mTSignature.getMethod(),inMTSignature.getMethod())) return true;
		}
		return false;
	}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------		
  public MethodTemplateSignature hasMethod(Method inMethod){
    for (MethodTemplateSignature mTSignature : getMethodTemplateSignatures()) {
    		Method newMethod = new Method(mTSignature.getMethod());
    		ApplyTypeParametersToMethod(newMethod);
			if (compareTwoMethdos(newMethod,inMethod)) return mTSignature;
		}
	return null;
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	
  private boolean compareTwoMethdos(Method method1, Method method2){
    if (method1.getName().equals(method2.getName())){
		 // if(method1.getType().equals(method2.getType())){
			  Integer numberOfParams = method1.getMethodParameters().size();
			  if ( numberOfParams== method2.getMethodParameters().size()) {
		          boolean allSame = true;
		          for (int i = 0; i < numberOfParams; i++)
		          {
		            if(!method1.getMethodParameter(i).getType().equals(method2.getMethodParameter(i).getType()))
		            {
		              allSame = false;
		              break;
		            }
		          }
		          if(allSame)
		          {
		            return true;
		          }
		     }
		 // }  
      }
	  return false;
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------   
}

class MethodTemplateSignature{
  MethodTemplateSignature(MethodTemplateSignature another)
  {
    this.modifier = another.getModifier();
    this.alias = another.getAlias();
    this.method = new Method(another.getMethod());
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------   
}


use Umple_Code_Trait.ump;
