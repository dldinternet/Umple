class SuperCodeGenerator {
  after constructor {
    UmpleToPrimitiveMap = new HashMap<String, String>();
    TraceLookupMap = new HashMap<String,String>();	
    ConstraintLookupMap = new HashMap<String,String>();
    initializeLangaugeBasedVariables();
  }

  Map <String,String> UmpleToPrimitiveMap;
  Map <String,String> TraceLookupMap;
  Map <String,String> ConstraintLookupMap;
	
  //This method is because of issue number 373;
  public void generate() {

  }

  public abstract void initializeLangaugeBasedVariables();

  public String getType(UmpleVariable av) {
    String myType = av.getType();
    if (myType == null || myType.length() == 0)
    {
      return UmpleToPrimitiveMap.get("String");
    }
    else if (UmpleToPrimitiveMap.containsKey(myType))
    {
      return UmpleToPrimitiveMap.get(myType);
    }
    else
    {
      return myType;
   	}
  }
  	
  public String translate(String keyName, TraceItem ti)
  {
	if (keyName.length()>5&&"trace".equals(keyName.substring(0,5)))
	{
	  return TraceLookupMap.get(keyName.substring(5).toLowerCase());
    }
    else 
    {
      return "INVALID KEYNAME IN TRANSLATE";
    }
  }
  	
  public String translate(String format, Constraint constraint){
    if(constraint==null)
      return "{0}";
    String expression = "";
    boolean insertNext = false;
    boolean strictNext = false;
    boolean plain = format.contains("Plain");
    String previousName = "";
    for(int i=0;i<constraint.numberOfExpressions();i++)
    {      
      ConstraintVariable expr = constraint.getExpression(i);
      if( expr.getType().equals("NAME"))
      {
        if(insertNext)
        {
          String name = (!plain?ConstraintLookupMap.get("accessor"):"")+
        		                      translate(format+":Plain",expr.getSubConstraint());
          expression = StringFormatter.format(expression,name,previousName);
          previousName = name;
          insertNext = false;
        }
        else
        {
          String name = (!plain?ConstraintLookupMap.get("accessor"):"")+
        		                      translate(format+":Plain",expr.getSubConstraint());
          expression+=name;
          previousName = name;
        }
      }
      else if( expr.getIsAttribute() )
      {
        String value;
        if(format.contains("allParameterOne")&&!strictNext)
        {
          if(!expr.getIsAssociation())
          {
             value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                     (expr.getFoundAttribute()==null?expr.getValue():translate("parameterOne",(Attribute)expr.getFoundAttribute()));
          }
          else 
          {
            if(expr.getIndex()==-1)
            {
              value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                      (expr.getFoundAttribute()==null?expr.getValue():translate("associationMany",(AssociationVariable)expr.getFoundAttribute()));
            }
            else {
              value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                      (expr.getFoundAttribute()==null?expr.getValue():translate("associationMany",(AssociationVariable)expr.getFoundAttribute())); 
              value = StringFormatter.format(ConstraintLookupMap.get("[]"),""+expr.getIndex(), value);
            }
          }
        }
        else if(Arrays.asList(format.split(":")[0].split(",")).contains(expr.getValue())&&!strictNext)
        {
          if(!expr.getIsAssociation())
          {
             value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                     (expr.getFoundAttribute()==null?expr.getValue():translate("parameterOne",(Attribute)expr.getFoundAttribute()));
          }
          else 
          {
            if(expr.getIndex()==-1 )
            {
              value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                      (expr.getFoundAttribute()==null?expr.getValue():translate("associationMany",(AssociationVariable)expr.getFoundAttribute()));
            }
            else {
              value = (!plain?ConstraintLookupMap.get("accessor"):"")+
                      (expr.getFoundAttribute()==null?expr.getValue():translate("associationMany",(AssociationVariable)expr.getFoundAttribute()));
              value = StringFormatter.format(ConstraintLookupMap.get("[]"),""+expr.getIndex(), value);
            }
          }
        }
        else 
        {
          value = (!plain?ConstraintLookupMap.get("accessor"):"")+expr.getValue();
          strictNext=false;
        }
        if(insertNext){
          expression = StringFormatter.format(expression,value,previousName);
          insertNext = false;
        }
        else {
          expression += value;
        }
      } 
      else // STATIC OR OPERATOR
      { 
        if(expr.getValue().equals("."))
        {
          strictNext=true;
        }
        if(expr.getIsOperator()) //Operator
        {
          String opValue = expr.getValue();
          if(!expr.getIsPrimitive()&&ConstraintLookupMap.containsKey(opValue))
          {
            if(insertNext)
            {
              expression = StringFormatter.format(expression,ConstraintLookupMap.get(opValue));
              insertNext = true;
            }
            else 
            {
              expression += ConstraintLookupMap.get(opValue);
              insertNext = true;
            }
          }
          else //Static
          {
			if(insertNext)
            {
              expression = StringFormatter.format(expression,opValue,previousName);
              insertNext = false;
            }
            else 
            {
              expression += opValue;
            }
          }
        }
        else if(insertNext){
          expression = StringFormatter.format(expression,expr.getValue());
          insertNext = false;
        }
        else {
          expression += expr.getValue();
        }
      }
    }
    if(plain)
    {
      return expression;
    }
    else if(format.contains("Not"))
    {
      expression = " !("+expression+")";
    }
    if(format.contains("Closed"))
    {
      return StringFormatter.format(ConstraintLookupMap.get("ifstatement")+"\n  {1}\n"+ConstraintLookupMap.get("end"),expression, "{0}");
    }
    else if(format.contains("Open"))
    {
      return StringFormatter.format(ConstraintLookupMap.get("ifstatement"),expression, "{0}");
    }
    return StringFormatter.format(ConstraintLookupMap.get("ifstatement")+"\n  {1}\n"+ConstraintLookupMap.get("end"),expression, "{0}");
  }
}