namespace cruise.umple.parser.analysis;
class Analyzer {
  /*
    This funciton is used for putting things into the global hashmap that contains all objects
  */
  protected void set(String string, Object object)
  {
    global.put(string, object);
  }
  /*
    This function goes through all the subtokens and invokes this analyzer's method(if it exists) which has the same name as the token
  */
  public void analyze(Token tokens)
  {
    for(Token token: tokens.getSubTokens())
    {
      if(handlers.get(token.getName())!=null)
      {
        try
        {
          handlers.get(token.getName()).invoke(this,token);
        }
        catch (IllegalArgumentException e)
        {
          e.printStackTrace();
        } 
        catch (IllegalAccessException e)
        {
          e.printStackTrace();
        }
        catch (InvocationTargetException e)
        {
          e.printStackTrace();
        }
      }
    }
  }
  /*
    abstract method for executing the rootrule onto the umplefile(for example)
  */
  public void execute()
  {
  }
  
  /*
    Inner class which is a wrapper for the objects that will go into the global hashmap
  */
  public class Getter<T>
  {
    public Getter()
    {
    }
    @SuppressWarnings("unchecked")
    public T get(String name)
    {
      return ((T)global.get(name));
    }
  }

}

class RuleBasedParser 
{
  //This variable exists to speed up multiple passes through the parser, say in junit tests, because the grammar analysis only has to be performed once.
  private static GrammarAnalyzer analyzer = null;
  private Token grootToken = null;

  public static GrammarAnalyzer getAnalyzer()
  {
    return analyzer;
  }

  public Token getGRootToken()
  {
    return grootToken;
  }

  /*
    Takes a root rule and uses it to start parsing. The result will be put into the root token passed. The parsing will be performed
    on the file. data is a DataPackage which needs to be initialized(using the init(Position)) before passing to this function.
    The data package will contain miscellaneous data that will be computed throughout the parsing, such as FailPosition(if parsing fails)
    and the location of couples(brackets and quotes).
  */
  public void parse(ChoiceRule root, Token token, String filename, ParserDataPackage data)
  {
    parsing++;
    data.setCouples(new HashMap<String,ParsingCouple>());
    BalancedRule.initialize(data.getInput(),data);
    int parseResult = root.parse(token, 0,data.getInput().length(),data.getInput(),data);
    if(parseResult==data.getInput().length())
    {
      setRootToken(token);
    }
    else
    {
      setRootToken(token);
      setFailedPosition(data.getPosition());
    }
    parsing--;
  }

  public void parse(ChoiceRule root, Token token, String filename,int line, ParserDataPackage data)
  {
    parsing++;
    data.setCouples(new HashMap<String,ParsingCouple>());
    BalancedRule.initialize(data.getLine(line),data);
    int parseResult = root.parse(token, 0,data.getLine(line).length(),data.getLine(line),data);
    if(parseResult==data.getInput().length())
    {
      setRootToken(token);
    }
    else
    {
      setRootToken(token);
      setFailedPosition(data.getPosition());
    }
    parsing--;
  }

  public void setupRules()
  {
    setupRules(false);
  }

  /**
   * After being passed all the grammar files by the UmpleInternalParser, this function is called to compute all the rules that are associated
   * to the umple language. For some reason this is computationally expensive, future implementations will hopefully be able to speed this up.
   */
  public void setupRules(boolean forceParse)
  {
    BufferedReader reader = null;
    InputStream resourceStream = null;
    boolean mustParse = false;
    try {
      File rulesfile = new File(new File("cruise.umple").getAbsolutePath()+File.separator+"bin"+File.separator+"rules.grammar");

      if(rulesfile.exists()&&rulesfile.canRead())
      {
        reader = new BufferedReader(new FileReader(rulesfile));
      }
      else
      {
        resourceStream = getClass().getResourceAsStream(File.separator+"rules.grammar");
        if(resourceStream == null)
        {
          mustParse = true;
          reader = null;
        }
        else
        {
          reader = new BufferedReader(new InputStreamReader(resourceStream));  
        }          
      }
      if(mustParse || forceParse)
      {
        Terminal.space(" \\t");
        ChoiceRule rulename = new Terminal("rulename","[a-zA-Z0-9_]+",false);
        ChoiceRule definition = new RepeatableRule("definition",0,Integer.MAX_VALUE);
        ChoiceRule openbrace = new Terminal("openbrace","\\(",false).dontCare();
        ChoiceRule closebrace = new Terminal("closebrace","\\)",false).dontCare();
        ChoiceRule opencurl = new Terminal("opencurl","(\\{|\")",false);
        ChoiceRule closecurl = new Terminal("closecurl","(\\}|\")",false);
        ChoiceRule otherRule = new ChainRule("otherrule",new Terminal("open","\\Q[[\\E",false).dontCare(),rulename,new Terminal("close","\\Q]]\\E",false).dontCare()).dontCare();
        ChoiceRule spaceSeparated = new BalancedRule("token","[",
            new ChainRule("multi",
                new Terminal("premodifier","[~!=*]?[*]?"),
                new Terminal("tokenname","([|][|]|[a-zA-Z0-9_,-]+)"),
                new Terminal("valuecolon","[:>]?",false),
                new Terminal("value",".*",false)).dontCare(),"]").dontCare();
        ChoiceRule options = new ChoiceRule("options",
            new ChainRule("braced",opencurl,definition,closecurl),
            new ChainRule("anonymousRule",openbrace,definition,closebrace, new Terminal("modifier","[*+?]?",false)),
            new ChainRule("otherrule",otherRule,new Terminal("modifier","[*+?]?",false)),
            new ChainRule("token",spaceSeparated,new Terminal("modifier","[*+?]?")),
            new Terminal("separator","[|]",false),
            new Terminal("spaces","",true).dontCare(),
            new ChainRule("terminal",new Terminal("terminal","(\\Q-(\\E|\\Q-)\\E|[^ \\t\\n\"\\{\\(\\}\\)]+)",false))).dontCare();

        definition.add(options);

        ChoiceRule rule = new ChoiceRule("rule",
            new ChainRule("layout",
                rulename,
                new Terminal("modifier","[-]?",false),
                new Terminal("colon","[:]",false).dontCare(),
                definition, new Terminal("newline", "[\\n]",false).dontCare()
                ).dontCare()
            );

        ChoiceRule root = rule;

        ParsingCouple.ignoreLevel = 1;
        grootToken = new Token("ROOT","");
        List<Thread> parsers = new ArrayList<Thread>();
        String[] keys = new String[]{"[","]"};
        grootToken = new Token("ROOT","");
        for(String filename:grammarFiles)
        {
          ParserDataPackage data = new ParserDataPackage(filename);
          data.getKeys().put("[]",keys);
          data.init(null);
          for(int i=0;i<data.numberOfLines();++i){
            if(!data.getLine(i).startsWith("//")&&!data.getLine(i).startsWith("\n")){
              parse(root,grootToken,filename,i, data);
            }
          }
        }
        analyzer = new GrammarAnalyzer();
        analyzer.analyze(grootToken);
        analyzer.setupTerminals();
        if(rulesfile.exists()&&rulesfile.canWrite()){
        	rulesfile.delete();
        }
        if(!rulesfile.exists())
        {
          if(new File("cruise.umple"+File.separator+"bin"+File.separator+"umple_core.grammar").canWrite())
          {
            rulesfile.createNewFile();
          }
          if(!rulesfile.canWrite()){
        	  return;
          }
          BufferedWriter writer = new BufferedWriter(new FileWriter(rulesfile));
          writer.write("");
          writer.append(analyzer.getRules().get("$ROOT$").toDeclareString(new StringBuilder()));
          writer.append("//END DECLARE\n");
          analyzer.getRules().get("$ROOT$").resetDeclare();
          writer.append(analyzer.getRules().get("$ROOT$").toCannotBeString(new StringBuilder()));
          writer.append("//END CANNOTBE\n");
          analyzer.getRules().get("$ROOT$").resetDeclare();
          writer.append(analyzer.getRules().get("$ROOT$").toRedoRegexString(new StringBuilder()));
          writer.append("//END REDOREGEX\n");
          writer.close();

          analyzer.getRules().get("$ROOT$").resetDeclare();
        }
      }
      else if(reader!=null)
      {
        String program = null;
        String currentLine = reader.readLine();
        analyzer = new GrammarAnalyzer();

        analyzer.getKeys().put("{}", new String[]{"{","}"});    
        analyzer.getKeys().put("\"", new String[]{"\"","\""});

        while(currentLine!=null){    
          if(currentLine.equals("//END DECLARE")){
            currentLine = reader.readLine();
            break;
          }
          String value = reader.readLine();


          todeclare.put(currentLine,value);
          if(program==null){
            program = currentLine;          
          }
          currentLine = reader.readLine();
        }
        while(currentLine!=null)
        {
          if(currentLine.equals("//END CANNOTBE"))
          {
            currentLine = reader.readLine();
            break;
          }
          int colon = currentLine.indexOf(":");
          String name = currentLine.substring(0,colon);
          evaluate(name);
          ((Terminal)choicerules.get(name)).setCannotBe(currentLine.substring(colon+1));
          currentLine = reader.readLine();
        }
        while(currentLine!=null)
        {
          if(currentLine.equals("//END REDOREGEX"))
          {
            currentLine = reader.readLine();
            break;
          }
          int colon = currentLine.indexOf(":");
          String name = currentLine.substring(0,colon);
          int colon2 = currentLine.indexOf(":",colon+1);
          evaluate(name);
          String regex =((Terminal)choicerules.get(name)).getRegex();
          if(choicerules.get(name).getOptional())
          {
            regex = regex.substring(0,regex.length()-1);
          }
          ((Terminal)choicerules.get(name)).redoRegex(regex,currentLine.substring(colon2+1),Boolean.parseBoolean(currentLine.substring(colon+1,colon2)));
          currentLine = reader.readLine();
        }
        evaluate(program);
        analyzer.set("$ROOT$",choicerules.get(program));
        reader.close();
      }
    } 
    catch (IOException e)
    {
      e.printStackTrace();
    }
  }
  /*
    Takes an umple file and parses it. It returns the ParseResult.
  */
  public ParseResult parse(UmpleFile file)
  {
    if(analyzer==null)
    {
      setupRules();
    }
    analyzer.init(file);
    analyzer.execute();
    setRootToken(analyzer.getRootToken());
    setParseResult(analyzer.getParseResult());
    return getParseResult();
  }
  
  public ParseResult parse(String ruleName, String input)
  {
    if(analyzer==null)
    {
      setupRules();
    }
    analyzer.init(ruleName, input);
    analyzer.execute();
    setRootToken(analyzer.getRootToken());
    setParseResult(analyzer.getParseResult());
    return getParseResult();
  }

  public static boolean evaluate(String hash)
  {
    String currentLine = todeclare.get(hash);
    if(currentLine==null)
    {
      return false;
    }
    String[] args = currentLine.split("[:]");
    String type = args[0];
    String name = args[1];
    if(type.equals("ChoiceRule"))
    {
      choicerules.put(hash,new ChoiceRule(name));
      if(name.equals("useStatement"))
      {
        choicerules.get(hash).setAction(analyzer.getActionedTokens().get("useStatement"));
      }
    }
    else if(type.equals("ChainRule"))
    {
      choicerules.put(hash,new ChainRule(name));
      
    }
    else if(type.equals("RepeatableRule"))
    {
      choicerules.put(hash,new RepeatableRule(name,Integer.parseInt(args[6]),Integer.parseInt(args[7])));
    }
    else if(type.equals("BalancedRule"))
    {
      choicerules.put(hash,new BalancedRule(name,args[6],args[7]));
    }
    else if(type.equals("RootRule")){
      choicerules.put(hash,new RootRule(name));
    }
    else if(type.equals("Terminal"))
    {
      String regex = currentLine.substring(
        currentLine.indexOf(":",
          currentLine.indexOf(":",
            currentLine.indexOf(":",
              currentLine.indexOf(":",
                currentLine.indexOf(":",
                  currentLine.indexOf(":",
                    currentLine.indexOf(":",
                      currentLine.indexOf(":",
                        currentLine.indexOf(":",
                          currentLine.indexOf(":",
                            currentLine.indexOf(":")+1)+1)+1)+1)+1)+1)+1)+1)+1)+1)+1);
      Terminal terminal = null;
      if(args[9].equals("true"))
      {
        terminal = new Terminal(name,regex);
      }
      else
      {
        terminal = new Terminal(name,regex,args[10].equals("true"));
      }
      if(args[6].equals("true"))
      {
        terminal.onlyValue();
      }
      if(args[7].equals("true"))
      {
        terminal.setCanBeNull(true);
      }
      if(args[8].equals("true"))
      {
        terminal.cannotHaveNewline();
      }
      choicerules.put(hash,terminal);
    }
    choicerules.get(hash).setNegate(args[3].equals("true"));
    choicerules.get(hash).setOptional(args[4].equals("true"));
    try
    {
      choicerules.get(hash).setSubrules(args[5]);
    }
    catch(Exception e)
    {

    }
    return true;
  }
}

class ParserDataPackage
{
  /*
    The passed Position can be null if this method was not invoked using a useStatement.
    It takes a file and reads it, it also initializes the couples which will be used for this file.
  */
  public void init(Position usePosition) 
  {
    String file = filename;
    filename = file.split("\\Q"+File.separator+"\\E")[file.split("\\Q"+File.separator+"\\E").length-1];
    int offset = 0;
    int linenumber = 0;
    linenumbers = new LinkedHashMap<Integer,Integer>();
    BufferedReader reader = null;
    InputStream resourceStream = null;
    try {
      if ((new File(file)).exists())
      {
        reader = new BufferedReader(new FileReader(file));
      }
      else
      {
        resourceStream = getClass().getResourceAsStream(file);
        reader = new BufferedReader(new InputStreamReader(resourceStream));
      }
      String line = reader.readLine();
      StringBuilder input2 = new StringBuilder();
      while(line!=null)
      {
        linenumbers.put(offset, linenumber);
        offset+=line.length()+1;
        linenumber++;
        lines.add(line+"\n");
        input2.append(line+"\n");
        line = reader.readLine();
      }
      input = input2.toString();
    }
    catch(NullPointerException n)
    {
      if(this.getParseResult()==null)
      {
        this.setParseResult(new ParseResult(false));
      }
      this.getParseResult().addErrorMessage(new ErrorMessage(1510,usePosition==null?new Position(filename,1,0,0):usePosition,filename));
    }
    catch(IOException e)
    {
      e.printStackTrace();
    } 
    finally 
    {
      try 
      {
        reader.close();
      } 
      catch(NullPointerException n)
      {        
      } 
      catch (IOException e)
      {      
        e.printStackTrace();
      }
    }
  }
  
  public void init(String rawinput, Position usePosition){
  String file = "temp";
  int offset = 0;
  int linenumber = 0;
  linenumbers = new LinkedHashMap<Integer,Integer>();
  try {
    for(String line:rawinput.split("\\n"))
    {
      linenumbers.put(offset, linenumber);
      offset+=line.length()+1;
      linenumber++;
      input += line+"\n";
    }
  }
  catch(NullPointerException n)
  {
    if(this.getParseResult()==null)
    {
      this.setParseResult(new ParseResult(false));
    }
    this.getParseResult().addErrorMessage(new ErrorMessage(1510,usePosition==null?new Position(filename,1,0,0):usePosition,filename));
  }
  couples = new HashMap<String,ParsingCouple>();    
  BalancedRule.initialize(input,this);
  }
}

interface RuleBasedParserAction {
  public void onSuccess(cruise.umple.compiler.Token token);
}

external Thread { }

class RuleBasedParserThread
{
  /*
    Each Thread will parse a separate file. When parsing is complete it will fill the useStatement token with the tokens computed from the
    file which was parsed. This run method performs this function as well as initializes the data package which will be used during the parsing
  */
  public void run()
  {
    HashMap<String,String[]> keys = data.getKeys();
    List<String> hasParsed = data.getHasParsed();
    ParseResult parseResult = data.getParseResult();
    data = new ParserDataPackage(filename);
    data.setKeys(keys);
    data.setHasParsed(hasParsed);
    data.setParseResult(parseResult);
    data.init(token.getPosition());
    Token temp = new Token("ROOT","");
    RuleBasedParser parser = new RuleBasedParser();
    parser.parse(root,temp,filename,data);
    Token answer = parser.getRootToken();
    synchronized(token)
    {      
      if(answer!=null)
      {
        new ChoiceRule("").addAllTokens(token, answer);
      }
      token.notifyAll();
    }
  }
  /* to make it linear
  public void join() throws InterruptedException{
  }
  public void start(){
    run();
  }*/
}

class GrammarAnalyzer {
  /*
    Sets up the actionTokens, and initializes the global variable
  */
  after constructor { 
    actionedTokens.put("useStatement", new ParserAction()
    {
      @Override
      public void onSuccess(Token token, ParserDataPackage data)
      {
        String value = token.getValue("use");
        synchronized(data.getHasParsed())
        {
          if(!data.getHasParsed().contains(value))
          {
            data.getHasParsed().add(value);
            RuleBasedParserThread thread = new RuleBasedParserThread(
              rules.get("$ROOT$"),
              token,
              umpleFile.getPath() + File.separator+value,
              data);
            threads.add(thread);
            thread.start();
          }
        }
      }
    });
    set("anon_index",0);
    set("analyzer",new Analyzer());
    set("stack",new Stack<ChoiceRule>());//new RuleStack());
    ChoiceRule root = new ChoiceRule("root");
    stacks.get("stack").push(root);
    Terminal.space(" \\t\\n");
    ParsingCouple.ignoreLevel = -1;
  }
  /*
    Must be called before use with the execute function, this function sets up the file for parsing
  */
  public void init (UmpleFile file)
  {
    setUmpleFile(file);
    input = file.getPath()+File.separator+file.getFileName();
    setData(new ParserDataPackage(input));
    getData().setKeys(keys);
    getData().init(null);
  }
  
  public void init(String ruleName, String input2) {
    input = input2;
    setData(new ParserDataPackage("temp"));
    getData().setKeys(keys);
    getData().init(input,null);  
  }

  /*
    Performs the parsing on the umple file.
  */
  public void execute()
  {
    setRootToken(new Token("ROOT",""));
    RuleBasedParser parser = new RuleBasedParser();
    parser.parse(rules.get("$ROOT$"),getRootToken(), input,getData());
    setRootToken(parser.getRootToken());
    while(threads.size()>0)
    {
      try 
      {
        RuleBasedParserThread thread = threads.remove(0);
        if(thread!=null)
        {
          thread.join();
        }
      } 
      catch (InterruptedException e)
      {
      }
    }
    setFailedPosition(parser.getFailedPosition());
    if(getFailedPosition()==null&&getData().getParseResult()==null)
    {
      setParseResult(new ParseResult(true));
    }
    else 
    {
      if(getData().getParseResult()!=null)
      {
        setParseResult(getData().getParseResult());
        return;
      }
      String badWord = getData().getInput().substring(getData().getPreviousFurthest(),getData().getFurthestGotten()).trim();
      int messageNumber = 1500;
      if("generate".equals(badWord) || "use".equals(badWord) || "strictness".equals(badWord) || "traceType".equals(badWord)) {
        messageNumber=1501;
      }
      else if("class".equals(badWord) || "association".equals(badWord) || "interface".equals(badWord) || "external".equals(badWord) || "associationClass".equals(badWord) || "stateMachine".equals(badWord)) {
        messageNumber=1502;
      }
      setParseResult(new ParseResult(false));
      getParseResult().addErrorMessage(new ErrorMessage(messageNumber,getFailedPosition(),badWord));
    }
  }
//--Analyze Rule Methods

  /*
    The rules token contains all the rules in a grammar file.
  */
  public void rules(Token token) {
    analyze(token);    
  }

  /*
    The rule token denotes the beginning of a rule definition.
  */
  public void rule(Token token) 
  {
    if(rules.get(getValue(token,"rulename"))==null)
    {
      set(getValue(token,"rulename"),getFirst()?new RootRule(getValue(token,"rulename")):new ChoiceRule(getValue(token,"rulename")));
      if(getFirst())
      {
        set("$ROOT$",rules.get(getValue(token,"rulename")));
        setFirst(false);
      }
    }
    ChoiceRule self = rules.get(getValue(token,"rulename"));
    if(getValue(token,"modifier")!=null)
    {
      self.dontCare();
    }
    if(actionedTokens.get(self.getName())!=null)
    {
      self.setAction(actionedTokens.get(self.getName()));
    }
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
    analyze(token);
    stacks.get("stack").pop();
  }

  /*
    The definition token is used both for the rule definition, and anonymous rules(rules containsed within paratheses).
  */
  public void definition(Token token) {
    ChoiceRule self = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
    analyze(token);
    stacks.get("stack").pop();
  }

  /*
    Otherrule tokens are for rule names within a definition, where the otherrule is defined elsewhere.
  */
  public void otherrule(Token token) {

    String modifier = getValue(token,"modifier");
    if(modifier!=null&&modifier.length()>0)
    {
      int start = 1;
      int end = 1;
      switch(getValue(token,"modifier").charAt(0))
      {
      case '*':
        start = 0;
        end = Integer.MAX_VALUE;
        break;
      case '?':
        start = 0;
        end = 1;
        break;
      case '+':
        start = 1;
        end = Integer.MAX_VALUE;
        break;
      }
      ChoiceRule star = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end).dontCare();
      set("anon_index",ints.get("anon_index")+1);
      stacks.get("stack").peek().add(star);
      stacks.get("stack").push(star);
    }

    if(rules.get(getValue(token,"rulename"))==null)
    {
      set(getValue(token,"rulename"),new ChoiceRule(getValue(token,"rulename")));
    }
    stacks.get("stack").peek().add(rules.get(getValue(token,"rulename")));  

    if(modifier!=null&&modifier.length()>0)
    {
      stacks.get("stack").pop();
    }
  }
  /*
    Simple method to handle token values.
  */
  public String getValue(Token token, String name)
  {
    String value = null;
    for(Token sub:token.getSubTokens())
    {
      if(sub.is(name))
      {
        value = sub.getValue();
      }
    }
    return value;
  }

  /*
    Terminals are keywords or syntax.
  */
  public void terminal(Token token) 
  {
    String value = getValue(token,"terminal");
    value = value.replace("-(","(").replace("-)",")").replace("OPEN_ROUND_BRACKET","(").replace("CLOSE_ROUND_BRACKET",")");
    
    String regex = "\\Q"+value+"\\E";
    
    Terminal terminal = null;
    
    if(value.length()==0?false:(""+value.charAt(value.length()-1)).matches("[a-zA-Z]"))
    {
      terminal = new Terminal("anonymous_terminal_"+ints.get("anon_index"),"("+regex+"[a-zA-Z]?)",false);
      terminal.setCannotBe(regex+"[a-zA-Z]");
    }
    else
    {
      terminal = new Terminal("anonymous_terminal_"+ints.get("anon_index"),regex,false);
    }
    stacks.get("stack").peek().add(terminal.onlyValue());
    
    set("anon_index",ints.get("anon_index")+1);
  }

  /*
    Tokens are of the form [{premodifier}tokenname{:value}] and denote a Terminal rule where the a Token is created with the value specified by some premodifier
  */
  public void token(Token token) 
  {
    ChoiceRule terminal = null;
    String name = getValue(token,"tokenname");
    String premodifier = getValue(token,"premodifier");
    String modifier = getValue(token,"modifier");
    String value = getValue(token,"value");
    boolean makeTerminal = true;

    modifier = modifier==null?"":modifier;
    premodifier = premodifier==null?"":premodifier;
    value = value==null?"":value.replace("OPEN_ROUND_BRACKET","(").replace("CLOSE_ROUND_BRACKET",")");
    String regex;
    boolean post = false;
    if("-".equals(name)&&"||".equals(value))
    {
      name = "||";
      regex = "\\Q||\\E";
    }
    else if(name.contains(",")&&name.length()>1)
    {
      regex = "[^\\s\\{\\}\\(\\);,]+";
      String[] names = name.split(",");
      String[] numbers = value.split(",");
      for(int i=0;i<names.length;i++)
      {
        Terminal term = new Terminal(names[i],"("+regex+")"+(i<numbers.length?((numbers[i].equals("0"))?"":"?"):(i==0?"":"?")),false);
        stacks.get("stack").peek().add(term);    
      }
      return;
    }
    else
    {
      if("=".equals(premodifier))
      {
        if("".equals(value))
        {
          regex = "\\Q"+name+"\\E";
          String cannotBeRegex = "";
          value = name;
          if(value.length()==0?false:(""+value.charAt(value.length()-1)).matches("[a-zA-Z]"))
          {
        	cannotBeRegex = regex+"[a-zA-Z]";
        	regex += "[a-zA-Z]?";
          }
          terminal = new Terminal(name,"("+regex+")",false);
          if(!cannotBeRegex.equals(""))
          {
            ((Terminal)terminal).setCannotBe(cannotBeRegex);
          }          
          makeTerminal = false;
        }
        else
        {
          regex = value;
          Set<String> sorted = new TreeSet<String>(new Comparator<String>()
          {
            @Override
            public int compare(String o1, String o2)
            {  
              if (o1.length() > o2.length())
              {
                return -1;
              } 
              else if (o1.length() < o2.length())
              {
                return 1;
              }
              return o1.compareTo(o2);
           }
          });
          for(String val:regex.split("\\Q|\\E"))
          {
            sorted.add(val);
          }

          regex = "";
          String cannotBeRegex = "";
          String pipe = "";
          String pipe2 = "";
          for(String val:sorted)
          {
            if(val.length()==0?false:(""+val.charAt(val.length()-1)).matches("[a-zA-Z]"))
            {
              regex += pipe + "\\Q"+val+"\\E"+"[a-zA-Z]?";
              cannotBeRegex += pipe2 + "\\Q"+val+"\\E"+"[a-zA-Z]";
              pipe2 = "|";
            }
            else
            {
              regex += pipe + "\\Q"+val+"\\E";              
            }
            pipe = "|";
          }
          terminal = new Terminal(name,"("+regex+")",false);
          if(!cannotBeRegex.equals(""))
          {
            ((Terminal)terminal).setCannotBe(cannotBeRegex);
          }            
          
          makeTerminal = false;
        }
      }
      else if("~".equals(premodifier))
      {
        regex = "[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>]|\\[\\])*)>+)?";
      }
      else if("!".equals(premodifier))
      {
        regex = value;
      }
      else
      {
        regex = value;
        if(!"*".equals(premodifier)&&"".equals(value))
        {
          post = true;
        }
      }
    }
    if("**".equals(premodifier))
    {
      regex = ".*";
      post = true;
    }
    else if("*".equals(premodifier))
    {
      regex = "[^\\n]*\\n\\s*";
      ChoiceRule rule = stacks.get("stack").peek();
      if(rule.size()>0&&rule.get(0) instanceof Terminal)
      {
        ((Terminal)rule.get(0)).cannotHaveNewline();
      }
    }
    if(!"".equals(modifier))
    {
      regex = "("+regex+")"+modifier;
    }
    if(makeTerminal)
    {
      terminal = new Terminal(name,regex,false);
    }
    if("~".equals(premodifier))
    {
      closeTerminal.add((Terminal)terminal);
    }
    if("**".equals(premodifier))
    {
      terminal.setOptional(true);
      ((Terminal)terminal).setCanBeNull(true);
    }
    else if("*".equals(premodifier))
    {
      terminal = new Terminal(name,regex);
      terminal.setOptional(true);
    }
    if(post)
    {
      openTerminal.add((Terminal)terminal);
    }
    if(!"".equals(modifier))
    {
      int start = 1;
      int end = 1;
      switch(token.getValue("modifier").charAt(0))
      {
          case '*':
            start = 0;
            end = Integer.MAX_VALUE;
            break;
          case '?':
            start = 0;
            end = 1;
            break;
          case '+':
            start = 1;
            end = Integer.MAX_VALUE;
            break;
      }
      if(start==0)
      {
        terminal.setOptional(true);
      }
      terminal = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end,terminal).dontCare();
        set("anon_index",ints.get("anon_index")+1);
    }  
    stacks.get("stack").peek().add(terminal);
  }

  /*
    These are rules that are specified within brackets, and are therefore not Tokenized.
  */
  public void anonymousRule(Token token)
  {
    ChoiceRule rule = new ChoiceRule("annoymous_rule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    int start = 1;
    int end = 1;
    String modifier = getValue(token,"modifier");
    if(modifier!=null&&modifier.length()>0)
    {
      switch(token.getValue("modifier").charAt(0))
      {
      case '*':
        start = 0;
        end = Integer.MAX_VALUE;
        break;
      case '?':
        start = 0;
        end = 1;
        break;
      case '+':
        start = 1;
        end = Integer.MAX_VALUE;
        break;
      }
    }
    ChoiceRule star = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end,rule).dontCare();
    set("anon_index",ints.get("anon_index")+1);

    stacks.get("stack").peek().add(star);
    stacks.get("stack").push(star);
    stacks.get("stack").push(rule);
    analyze(token);
    stacks.get("stack").pop();
    stacks.get("stack").pop();
  }
  
  /*
    {} and "" are special couple characters and are handled by making a BalancedRule which will ensure that the { is paired with the proper } and so on
  */
  public void braced(Token token)
  {
    ChoiceRule rule = new ChoiceRule("annoymous_rule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    ChoiceRule multi = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    String open = getValue(token,"opencurl");
    String close = getValue(token,"closecurl");
    ChoiceRule couple = new BalancedRule("annoymous_braced_"+ints.get("anon_index"),
        open,
        rule,
        close).dontCare();
    String key = open+close;
    if(!keys.containsKey(key))
    {
      keys.put(key,new String[]{open,close});
    }
    set("anon_index",ints.get("anon_index")+1);
    multi.add(couple);

    stacks.get("stack").peek().add(multi);
    stacks.get("stack").push(couple);
    stacks.get("stack").push(multi);
    stacks.get("stack").push(rule);
    analyze(token);
    stacks.get("stack").pop();
    stacks.get("stack").pop();
    stacks.get("stack").pop();
  }
  /*
    The separator token denotes the | in a rule. It means that everything before a separator is contained within one Rule and everything
    after the | is contained in a separate Rule. The parent to both of these rules is a ChoiceRule, meaning that each of the rules created
    will be tried.
  */
  public void separator(Token token)
  {
    stacks.get("stack").pop();
    ChoiceRule self = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
  }
  
  /*
    There are some terminals that need to use their surroundings to determine what they can and cannot take on as values
    this function iterates through all such terminals
  */
  public void setupTerminals()
  {
    for(Terminal terminal:openTerminal)
    {
      setupTerminal(terminal);
    }
    for(Terminal terminal:closeTerminal)
    {
      setupAlphanumericTerminal(terminal);
    }
  }
  /*
    Similar to the setupTerminal function this function makes sure that an alphanumeric does not take a value that is the value of then next terminal
    for instance if an association looks like * -- 1 Student sorted { }; the rolename is student not sorted.
    This works also for having * -- 1 Student sorted sorted { }; which will be a sorted list of students called sorted. (i.e. if the next one is accounted for then everything proceeds as normal)
  */
  public void setupAlphanumericTerminal(Terminal terminal)
  {
    ChoiceRule child = null;
    ChoiceRule parent = terminal;
    int index = 0;
    boolean optional = false;
    while(true)
    {
      child = parent;
      parent = parent.getParent();
      while(!(parent instanceof ChainRule)&&!(parent instanceof RepeatableRule))
      {
        child = parent;
        parent = parent.getParent();
        if(parent==null)
        {
          return;
        }
      }
      if(parent instanceof ChainRule)
      {
        index = parent.indexOf(child);
        if(index+1<parent.size())
        {
          optional = parent.get(index+1).isOptional();
          break;
        }
      }
      else if(parent instanceof RepeatableRule && ((RepeatableRule)parent).getMax()>1)
      {
        index = -1;
        optional = parent.isOptional();
        break;
      }
    }
    if(!"".equals(parent.get(index+1).getFirstValue()))
    {
      boolean shouldSet = false;
      for(String str:parent.get(index+1).getFirstValue().replace("\\Q", "").replace("\\E", "").split("|"))
      {
        if(str.matches(terminal.getRegex()))
        {
          shouldSet = true;
          break;
        }
      }
      if(shouldSet)
      {
        terminal.setCannotBe(parent.get(index+1).getFirstValue());
      }
    }
      
  }
  
  /*
    Sets up the tokens with no premodifier to make sure they stop at the right place,
    for instance [type] [=list[]]? should stop before the [], so the type only contains String, instead of String[]
  */  
  public void setupTerminal(Terminal terminal)
  {
    ChoiceRule child = null;
    ChoiceRule parent = terminal;
    int index = 0;
    boolean optional = false;
    String value = "";
    while(true)
    {
      child = parent;
      parent = parent.getParent();
      while(!(parent instanceof ChainRule)&&!(parent instanceof BalancedRule)&&!(parent instanceof RepeatableRule))
      {
        child = parent;
        parent = parent.getParent();
        if(parent==null)
        {
          return;
        }
      }
      if(parent instanceof ChainRule)
      {
        index = parent.indexOf(child);
        if(index+1<parent.size())
        {
          optional = parent.get(index+1).isOptional();
          
          if(parent.get(index+1).getFirstValue().equals(""))
          {
            value = "";
          }
          else if(parent.get(index+1).getFirstValue().charAt(parent.get(index+1).getFirstValue().length()-1)=='?')
          {
        value = parent.get(index+1).getFirstValue().substring(0,parent.get(index+1).getFirstValue().length()-1);
        }
        else
        {
          value = parent.get(index+1).getFirstValue();
        }
        /* 
        Future developements: if you have a rule [rule1] [rule2]? [rule3]?
                              then rule1 should be optionally delimited by rule2 and rule3
                              currently it is only delimited by rule2
                              the code below does this, except it does not work when the rule 3 is an alphanumeric
          if(optional)
          {
            index++;
            while(index+1<parent.size()&&parent.get(index).isOptional())
            {
              if(parent.get(index+1).getFirstValue().charAt(parent.get(index+1).getFirstValue().length()-1)=='?')
              {
            value += "|"+parent.get(index+1).getFirstValue().substring(0,parent.get(index+1).getFirstValue().length()-1);
            }
            else
            {
              value += "|"+parent.get(index+1).getFirstValue();
            }              
              index++;
            }
          }*/
          break;
        }
      }
      else if(parent instanceof BalancedRule)
      {
        if(!terminal.getRegex().equals(".*"))
        {
          terminal.redoRegex("[^\\s\\{\\}\\(\\);,]+");
        }
        return;
      }
      else if(!terminal.getRegex().equals(".*")&&parent instanceof RepeatableRule && ((RepeatableRule)parent).getMax()>1)
      {
        value = parent.get(0).getFirstValue();
        optional = parent.isOptional();
        break;
      }
    }
    if(terminal.getRegex().equals(".*"))
    {
      if(!"".equals(value))
      {
        terminal.redoRegex("^((?!"+value+").)*");
      }
    }
    else 
    {
      if(!"".equals(value))
      {
        value = value.replace(
             "[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>]|\\[\\])*)>+)?",
             "\\s[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>]|\\[\\])*)>+)?");
        
        terminal.redoRegex("([^\\s\\{\\}\\(\\);,<]|<[^>]*>+)+",
          value,
          optional);
      }
      else
      {
        terminal.redoRegex("[^\\s\\{\\}\\(\\);,]+");
      }
    }
  }
  
  public void analyze(Token tokens)
  {
    for(Token token: tokens.getSubTokens())
    {
      if(token.is("rule"))
      {
        rule(token);
      }
      else if(token.is("definition"))
      {
        definition(token);
      }
      else if(token.is("otherrule"))
      {
        otherrule(token);
      }
      else if(token.is("anonymousRule"))
      {
        anonymousRule(token);
      }
      else if(token.is("token"))
      {
        this.token(token);
      }
      else if(token.is("separator"))
      {
        separator(token);
      }
      else if(token.is("terminal"))
      {
        terminal(token);
      }
      else if(token.is("braced"))
      {
        braced(token);
      }
    }
  }
}

