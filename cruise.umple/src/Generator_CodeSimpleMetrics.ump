/*Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This generates simple metrics from Umple
  generate SimpleMetrics;
in your umple file, or the command line option
  -g SimpleMetrics

*/
 
namespace cruise.umple.compiler;
//import java.io.BufferedReader.*;
//import  java.io.FileReader;
//import java.io.IOException;
//import java.util.HashMap;
//import java.util.Map;

class SimpleMetricsGenerator{
  StringBuilder code = new StringBuilder();
  
  public void generate (){
  	
  	// Output basic file header
    code.append(">>>Metrics generated by Umple from "+model.getUmpleFile().getSimpleFileName()+".ump\n\n");
  	
	
	// GET DATA ABOUT LINES (CODE, BLANKS, COMMENTS)
  	CodeMetrics codemetrics = new CodeMetrics();
  	codemetrics.setModel(model);
  	codemetrics.setCode(code);
    codemetrics.calculate(); 
  	
  	// GET DATA FROM CLASSES
  	ClassMetrics classmetrics = new ClassMetrics();
  	classmetrics.setModel(model);
  	classmetrics.setCode(codemetrics.getCode());
    classmetrics.calculate(); 
    
    // GET DATA FROM STATE MACHINES
  	StateMachineMetrics SMMeasure = new StateMachineMetrics();  	
  	SMMeasure.setModel(model);
  	SMMeasure.setCode(classmetrics.getCode());
  	SMMeasure.calculate();
  	
  	model.setCode(code.toString());
    writeModel();
    return;
  }
  
  // Output the metrics to a file 
  void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".metrics";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating simple metrics." + e, e);
    }
  } 
     
} // END CLASS


/*************************************************
 * 
 * CLASS USED TO COUNT MEASURE CODE
 * 
 *************************************************/
 
class CodeMetrics {
	isA SimpleMetricsGenerator;
	StringBuilder code = null;
	UmpleModel model=null;
	
	void calculate(){
	  // COUNT LINES PER FILE 
      int totalLineCount = 0; 
      int totalLoc = 0;
      int totalComments = 0;
      int totalBlanks = 0;
	  CountLines cl = new CountLines();
	  
	  
	  java.util.Set<String> allUmpFiles = new java.util.HashSet<String>();
      String fn = null;
  
      // Iterate through all the classes in the system, gathering statistics
      for (UmpleClass uClass : model.getUmpleClasses()) {
        // Loop through all the places where parts of this class were
        // found in the code, gathering all the files
        for (Position p : uClass.getPositions()) {
          fn=p.getFilename();
          allUmpFiles.add(fn); // allUmpFiles is a set, so duplicates are removed
        }
      }

      java.util.List<String>title  = new java.util.ArrayList<String>();
      title.add(" file                                                                    ");
      title.add("    LOC    ");
      title.add(" Comment Lines ");
      title.add(" Blank Lines ");
      title.add(" Total of Lines ");
      code.append(Format.repeat("-",135)+"\n");
            
      for (int i=0;i<title.size();i++){ code.append("|"+title.get(i));  }
      code.append(" |\n");          
      code.append(Format.repeat("-",135)+"\n");
      
	  
      for( String fn1 : allUmpFiles){
          int fileLineCount = 0;
     
         try {
             cl = countLinesInFile(fn1);
             /*  code.append("\n      LOC = "+cl.getCountCode());
             code.append("\n      Comment Lines = "+cl.getCountComments());
             code.append("\n      Blank Lines = "+cl.getCountBlanks());   
             code.append("\n      Total of Lines = "+cl.getCountLines()+'\n');    
             */
         
             //String s = Format.repeat(" ", title.get(1).length()-(""+cc.getCountAssociations()).length() );
             code.append( "| " +fn1+ Format.repeat(" ", title.get(0).length()-(""+fn1).length()-1 ) );
             code.append( "| " +Format.repeat(" ", title.get(1).length()-(""+cl.getCountCode()).length()-1 )+ cl.getCountCode() );
             code.append( "| " +Format.repeat(" ", title.get(2).length()-(""+cl.getCountComments()).length()-1 )+ cl.getCountComments() );
             code.append( "| " +Format.repeat(" ", title.get(3).length()-(""+cl.getCountBlanks()).length()-1 )+ cl.getCountBlanks() );
             code.append( "| " +Format.repeat(" ", title.get(4).length()-(""+cl.getCountLines()).length()-1 )+ cl.getCountLines() );
             code.append( " |\n" ); // closing the record. One record one line.
             code.append(Format.repeat("-",135)+"\n");
          }
	 	  catch (java.io.IOException e) {
             try {
                 cl = countLinesInFile(model.getUmpleFile().getPath()+java.io.File.separator+fn1);
                 /*code.append ("\n      LOC = "+cl.getCountCode());
                 code.append("\n      Comment Lines = "+cl.getCountComments());
                 code.append("\n      Blank Lines = "+cl.getCountBlanks());
                 code.append("\n      Total of Lines = "+cl.getCountLines()+'\n'); 
                  */
              
                 code.append(fn1+ Format.repeat(" ", title.get(0).length()-(""+fn1).length() ) );
                 code.append( "| " +Format.repeat(" ", title.get(1).length()-(""+cl.getCountCode()).length() )+ cl.getCountCode() );
                 code.append( "| " +Format.repeat(" ", title.get(2).length()-(""+cl.getCountComments()).length() )+ cl.getCountComments() );
                 code.append( "| " +Format.repeat(" ", title.get(3).length()-(""+cl.getCountBlanks()).length() )+ cl.getCountBlanks() );
                 code.append( "| " +Format.repeat(" ", title.get(4).length()-(""+cl.getCountLines()).length() )+ cl.getCountLines() );
                 code.append( " |\n" ); // closing the record. One record one line.
                 code.append(Format.repeat("-",135)+"\n");
          
              }
              catch (java.io.IOException e2) {  
                 fileLineCount = 0;
                 cl.setCountLines(0);
                 code.append("Unreadable\n");
              } 
            }
   	        totalLoc += cl.getCountCode();
            totalComments += cl.getCountComments();
            totalBlanks += cl.getCountBlanks();
            totalLineCount += cl.getCountLines();  
	   
	    }
  	    code.append("\n\n");
        code.append("\n  Total Line of Code = "+totalLoc);
        code.append("\n  Total Comment Lines  = "+totalComments );
        code.append("\n  Total Blank Lines  = "+totalBlanks);
        code.append("\n  Total Total of Lines = "+totalLineCount + "\n");
	    code.append("\n\n");
		return;
	}
	
	
	
	CountLines countLinesInFile(String filename)throws java.io.IOException{
    //CountLines countLinesInFile(String filename) throws IOException
     CountLines cl = new CountLines();
     cl.setCountLines(0);
     cl.setCountComments(0);
     cl.setCountBlanks(0);
     cl.setCountCode(0);
  
      boolean insideblock=false;
     //System.out.println("processing:"+filename);
     // try {
          int ind1,ind2,ind3;
          java.io.FileReader arq = new java.io.FileReader(filename);
          java.io.BufferedReader lerArq = new java.io.BufferedReader(arq);
          String orgline;
          String line = lerArq.readLine(); // Read first line of a file
      	  
          while (line != null) {
          ind1=-1;
          ind2=-1;
          ind3=-1;
          
          //System.out.println(line);
          
          cl.incCountLines();
          line = line.replaceAll(" ",""); // Eliminate all spaces
          line = line.replaceAll("\t",""); // Eliminate all tabs \t
           
          // destroy quoted/string          
          int pos1, pos2 = -1;
          if ( (pos1 = line.indexOf("\"")) >= 0 ){
          	if ( ( (pos2= line.indexOf("\"",pos1+1)) > 0 ) && (pos2 > pos1) ){
         		line = line.substring( 0, pos1+1 ) + line.substring( pos1 + (pos2-pos1), line.length() ) ;
          	}
          }
          // System.out.println(line + line.length());
          //System.out.print(line);
          if ( line.length() == 0){
            cl.incCountBlanks();
            //System.out.println("[blank]");
          }else{      
            //comment in one line
            if ( ((ind1 = line.indexOf("//")) != -1) && (!insideblock) ) {
              cl.incCountComments();
              line = line.substring(0,2); // consume the line to avoid parsing mistakes
              //System.out.println("[//]");
            }
            // block of comments
            if (insideblock){
              cl.incCountComments();
              //System.out.println("[/* inside */]");
              if ( (ind3 = line.indexOf("*/")) != -1 ) {
                insideblock=false;
              }
            } 
            else if ( ((ind2 = line.indexOf("/*")) != -1) && (!insideblock) )
            {
              cl.incCountComments();
              //System.out.println("[/* */]");
              if ( (ind3 = line.indexOf("*/")) == -1 ) {
                insideblock = true;
              }
            }
            // line of code
            if  ( ( (!insideblock) && (  (ind1 > 0) || (ind2 > 0) ) )|| // ind1 check "//"  and ind 2 check "/*"
            	     ( (ind3 > 0) && (ind3 < line.length()-2) ) || // close braces before code line 
                     ( (ind1==-1) && (ind2==-1) && (ind3==-1) && (!insideblock)  ) //
                 )  {
                cl.incCountCode();     
                //System.out.println("[code] "+ind1+", "+ind2+", "+ind3+", "+insideblock);   
            }
          }
            line = lerArq.readLine(); // get next line or value null if doesn't have another one
          } // close while (line != null)
          arq.close();
/*          
      } catch (java.io.IOException e) {
          System.err.printf("Erro na abertura do arquivo: %s.\n",
            e.getMessage());
      }
*/
       //System.out.println("======================="+cl.toString());
       return cl;
   } // End method	
}



/*************************************************
 * 
 * CLASS USED TO MEASURE CLASSES
 * 
 *************************************************/
class ClassMetrics{
	isA SimpleMetricsGenerator;
	StringBuilder code = null;
	UmpleModel model=null;
	
	void calculate(){
	  CountClass cc = new CountClass();	
      int smCount = 0;
      int classCount = 0;

      code.append( "\n\n\n");
      code.append(Format.repeat("*",126) + "\n" );
      code.append(Format.repeat(" ",20)+" C L A S S   M E A S U R E S "+"\n");
      code.append(Format.repeat("*",126)+"\n");
   
	  // CALCULATE SOME CLASS METRICS
      // create a map in order to have several metric objects about the same class
      java.util.Set<String> allUmpFiles = new java.util.HashSet<String>();
      String fn = null;
      // Iterate through all the classes in the system, gathering statistics
      for (UmpleClass uClass : model.getUmpleClasses()) {   	      
        // Loop through all the places where parts of this class were
        // found in the code, gathering all the files
        for (Position p : uClass.getPositions()) {
          fn=p.getFilename();
          allUmpFiles.add(fn); // allUmpFiles is a set, so duplicates are removed
         }
      }
      java.util.Map<UmpleClass, CountClass> mapOfUmpleClass = new java.util.HashMap<UmpleClass, CountClass>();
      for ( UmpleClass uClass : model.getUmpleClasses() ) {
          cc= countDataClass( uClass); 
          mapOfUmpleClass.put(uClass, cc);     
      }    
    
      java.util.List<String>title = new java.util.ArrayList<String>();
      title.add(" Class Name                   ");
      title.add(" #State Machines ");
      title.add(" #Associations ");
      title.add(" Subclasses ");
      title.add(" #Attributes ");
      title.add(" #Methods ");
      title.add(" #Method Parameters ");
      code.append(Format.repeat("-",126)+"\n");
      for (int i=0;i<title.size();i++){ code.append("|"+title.get(i));  }
      code.append(" |\n");
      code.append(Format.repeat("-",126)+"\n");
          
      java.util.Set<UmpleClass> keys = mapOfUmpleClass.keySet(); 
      classCount=0;
      smCount=0;
      for (UmpleClass key : keys) {
        classCount++;  
        cc= (CountClass) mapOfUmpleClass.get(key);            
        code.append( "| " +key.getName()+ Format.repeat(" ", title.get(0).length()-(""+key.getName()).length()-1 ) );
        code.append( "| " +Format.repeat(" ", title.get(1).length()-(""+cc.getCountStateMachines()).length()-1 )+ cc.getCountStateMachines() );
        smCount += cc.getCountStateMachines();
        code.append( "| " +Format.repeat(" ", title.get(2).length()-(""+cc.getCountAssociations()).length()-1 )+ cc.getCountAssociations() );
        code.append( "| " +Format.repeat(" ", title.get(3).length()-(""+cc.getCountSubclasses()).length()-1 )+ cc.getCountSubclasses() );
        code.append( "| " +Format.repeat(" ", title.get(4).length()-(""+cc.getCountAttributes()).length()-1 )+ cc.getCountAttributes() );
        code.append( "| " +Format.repeat(" ", title.get(5).length()-(""+cc.getCountMethods()).length()-1 )+ cc.getCountMethods() );
        code.append( "| " +Format.repeat(" ", title.get(6).length()-(""+cc.getCountParameters()).length()-1 )+ cc.getCountParameters() );
        code.append( " |\n" ); // closing the record. One record one line.
        code.append(Format.repeat("-",126)+"\n");
      }
    
      // TOTAL OF CLASSES, STATE MACHINES, SOURCE FILES 
      code.append("\n\n");
      code.append(Format.repeat("-",50)+"\n");
      code.append(" SOME TOTALS:\n");
      code.append(" class count = "+classCount+"\n");
      code.append(" state machine count = "+smCount+"\n");
      code.append(" source file count = "+allUmpFiles.size()+"\n");
      code.append(Format.repeat("-",50)+"\n");
	  super.setCode(code);
	  return;
	}// end of method
	
	
	CountClass countDataClass( UmpleClass uClass){
	  int classCount=0;
      CountClass countclass = new CountClass();
      
      Attribute attribute = null;
      Method method = null;
      MethodParameter parameter = null;
      Association vassociation = null;
       
      //System.out.println("=======================================");
      //for (UmpleClass uClass : model.getUmpleClasses())
      
        if (uClass!=null){
          //System.out.println( "Class: "+uClass.getName() );
         
          //Look for State Machines
          for (StateMachine sm : uClass.getStateMachines()) {
            countclass.incStateMachines();
          }   
        
          // Look for subclasses
          UmpleClass subclass=null;
          java.util.List subclasslist = uClass.getSubclasses();
          if (subclasslist.size()>0){
            java.util.Iterator it = subclasslist.iterator();

          //System.out.println( "File: "+fn+"    class: "+uClass.getName() );
            while ( it.hasNext() ) {
              subclass = (UmpleClass)it.next();
              //System.out.println( "      Subclasse: "+ subclass.getName() );
              countclass.incCountSubclasses();
              //countclass.incCountAttributes();
            }
          }
        
          // Look for Associations
          Association[] associationlist = uClass.getAssociations();
          for( int i = 0; i < associationlist.length; i++ )
          {
            vassociation = associationlist[i];
            //System.out.println( "      Association: "+ vassociation.getName() );
            countclass.incCountAssociations();
          }
        
          // Look for Attributes
          java.util.List attributelist = uClass.getAttributes();
          if (attributelist != null){
            java.util.Iterator it = attributelist.iterator();
  
            while ( it.hasNext() ) {
              attribute = (Attribute)it.next();
              //System.out.println( "      Attribute: "+ attribute.getName() );
              countclass.incCountAttributes();
            }
          }

          // Look for Methods
          java.util.List methodlist = uClass.getMethods();
          //System.out.println("Method list= "+methodlist.size());
          if (methodlist != null){
            java.util.Iterator it1 = methodlist.iterator();
                    
            while ( it1.hasNext() ) {
              method = (Method)it1.next();
              //System.out.println("       Method: "+ method.getName() );
              countclass.incCountMethods();
              
              // Look for Parameters
              java.util.List parameterlist = method.getMethodParameters();
              if (parameterlist != null){
                java.util.Iterator it3 = parameterlist.iterator();
                      
                while ( it3.hasNext() ) {
                  parameter = (MethodParameter)it3.next();
                  //System.out.println("             Parameter: "+ parameter.getName() );
                  //countclass.incCountMethods();
                }
              }
            }
          }
        }
 	    return countclass;	
	} // end of method
	
}// end of class ClassMetrics


/*******************************************************
 * 
 * CLASS USED TO COUNT MEASURE STATE MACHINES
 * 
 *******************************************************/
class StateMachineMetrics{	 
	isA SimpleMetricsGenerator;
	StringBuilder code = null;
	UmpleModel model=null;
	CountSM countsm = new CountSM();
	
	void calculate(){
      int totalStateMachinesPerClass= 0;
	  int totalStatesPerClass=0;
	  int smCount=0;
	  int totalStateMachines= 0;
      // Output basic file header
      code.append( "\n\n\n");
      code.append(Format.repeat("*",126)+"\n");
      code.append(Format.repeat(" ",20)+"S T A T E   M A C H I N E  ( S M )   M E A S U R E S"+"\n");
      code.append(Format.repeat("*",126)+"\n");
      
	  java.util.List<String>title = new java.util.ArrayList<String>();
      title.add(" Class Name                   ");
      title.add(" #State Machines ");
      title.add(" #Total of States ");
	  title.add(" #Transitions ");
      title.add(" #Total Events ");
      title.add(" #Total Actions ");
      title.add(" #States like SM ");
      code.append(Format.repeat("-",136)+"\n");
      for (int i=0;i<title.size();i++){ code.append("|"+title.get(i));  }
      code.append(" |\n");
      code.append(Format.repeat("-",136)+"\n");
	  
  
      for (UmpleClass uClass : model.getUmpleClasses()) {  
	    if (uClass!=null){

		  code.append( "| " +uClass.getName()+ Format.repeat(" ", title.get(0).length()-(""+uClass.getName()).length()-1 ) );

          //Look for State Machines
          totalStateMachinesPerClass= 0;
          totalStatesPerClass=0;
        
		  countsm.setTotalStateMachinesPerClass(0);
		  countsm.setTotalStates(0);
		  countsm.setTotalTransitions(0);
		  countsm.setTotalEvents(0);
		  countsm.setTotalActions(0);
		  countsm.setTotalNestedStateMachine(0);
		  
          for (StateMachine sm : uClass.getStateMachines()) {          
            ++totalStateMachinesPerClass;
			countsm.incTotalStateMachinesPerClass(1);
            nestedSM (sm, 0);

          }
		  code.append( "| " +Format.repeat(" ", title.get(1).length()-(""+countsm.getTotalStateMachinesPerClass()).length()-1 )+ countsm.getTotalStateMachinesPerClass() );
          code.append( "| " +Format.repeat(" ", title.get(2).length()-(""+countsm.getTotalStates()).length()-1 )+ countsm.getTotalStates() );
          code.append( "| " +Format.repeat(" ", title.get(3).length()-(""+countsm.getTotalTransitions()).length()-1 )+ countsm.getTotalTransitions() );
          code.append( "| " +Format.repeat(" ", title.get(4).length()-(""+countsm.getTotalEvents()).length()-1 )+ countsm.getTotalEvents() );
          code.append( "| " +Format.repeat(" ", title.get(5).length()-(""+countsm.getTotalActions()).length()-1 )+ countsm.getTotalActions() );
          code.append( "| " +Format.repeat(" ", title.get(6).length()-(""+countsm.getTotalNestedStateMachine()).length()-1 )+ countsm.getTotalNestedStateMachine() );
          code.append( " |\n" ); // closing the record. One record one line.
          code.append(Format.repeat("-",136)+"\n");
          countsm.incTotalStateMachines(countsm.getTotalStateMachinesPerClass());
          totalStateMachines+=totalStateMachinesPerClass;
		  smCount += countsm.getTotalStateMachinesPerClass();
        }
      }

      code.append("\n  Total Total of States Machines = "+countsm.getTotalStateMachines() + "\n");
      code.append("\n  Total Total of Transitions = "+countsm.getTotalTransitions() + "\n");

      code.append("\n  Total Total of States Machines = "+countsm.getTotalStateMachines() + "\n");
      code.append("\n  Total Total of Transitions = "+countsm.getTotalTransitions() + "\n");
      code.append("\n\n");
    
      super.setCode(code);
      return;		
	}// End of method main
	
	
	void nestedSM (StateMachine sm, int level){
      int totalNestedStateMachine=0;  
  	  int totalStates= 0;
  	  int totalTransitions= 0;
  	  int totalEvents= 0;
  	
      ++totalNestedStateMachine; 
      countsm.incTotalNestedStateMachine(1);
      //code.append( Format.repeat(" ",(level+1)*3+2)+"Name of State Machine: "+sm.getName() + "\n" ); 
	  
      // Look for states
      totalStates= 0;
      for (State states: sm.getStates()) {          
        ++totalStates;
		countsm.incTotalStates(1);
        //code.append( Format.repeat(" ",(level+2)*3+2)+"Name of State: "+states.getName()  + "\n");
        
        // Look for Actions
		for (Action actions: states.getActions()) {  
		  countsm.incTotalActions(1);
		}
		
        // Look for transitions
        totalTransitions= 0;
        Event event=null;
        for (Transition transition: states.getTransitions()) {
          ++totalTransitions;
		  countsm.incTotalTransitions(1);
          if ( (event= transition.getEvent()) == null ){
            //code.append( Format.repeat(" ",(level+3)*3+2)+"Transition: "+transition.getFromState().getName()+" --> "+transition.getNextState().getName() + "\n" );
          }
          else { 
            countsm.incTotalEvents(1);		  
           // code.append( Format.repeat(" ",(level+3)*3+2)+"Transition: "+transition.getFromState().getName()+" --> "+transition.getNextState().getName() + " by event "+transition.getEvent().getName() + "\n" );    	
          }
        }
                   
        // Look for Nested StateMachine
        totalNestedStateMachine=0;
        for (StateMachine smnested: states.getNestedStateMachines()) {
          ++totalNestedStateMachine;
		  countsm.incTotalNestedStateMachine(1);
          nestedSM(smnested,level+1);     
        }               
      }
      //System.out.println( "          States: "+totalStates );
      //totalStatesPerClass+=totalStates;
	  return ;
    } //END METHOD	
   
} // END OF CLASS StateMachineMetrics


class CountSM{	 
    int totalStateMachines= 0;
    int totalStateMachinesPerClass= 0;
    int totalStatesPerClass= 0;
    int totalStates= 0;
	int totalEvents= 0;
    int totalTransitions= 0;
    int avgTransitionsPerEvent= 0;
    int avgTransitionsPerClass= 0;
    int totalActions= 0;
    int totalNestedStateMachine= 0;
    int maxNestingDepth= 0;
    int avgNestingDepth= 0;
	
	void incTotalStateMachines(int a){
      this.totalStateMachines+=a;
    } 
	void incTotalStateMachinesPerClass(int a){
      this.totalStateMachinesPerClass+=a;
    } 	
	void incTotalStatesPerClass(int a){
      this.totalStatesPerClass+=a;
    } 
	void incTotalStates(int a){
      this.totalStates+=a;
    }
	void incTotalEvents(int a){
      this.totalEvents+=a;
    }
	void incTotalTransitions(int a){
      this.totalTransitions+=a;
    } 	
	void incAvgTransitionsPerEvent(int a){
      this.avgTransitionsPerEvent+=a;
    } 	 	
	
	void incAvgTransitionsPerClass(int a){
      this.avgTransitionsPerClass+=a;
    } 	
	void incTotalActions(int a){
      this.totalActions+=a;
    }
	void incTotalNestedStateMachine(int a){
      this.totalNestedStateMachine+=a;
    }
	void incMaxNestingDepth(int a){
      this.maxNestingDepth+=a;
    }
	void incAvgNestingDepth(int a){
      this.avgNestingDepth+=a;
    }
	
}

class CountClass {
    int countStateMachines =0;
    int countAssociations =0;
    int countSubclasses =0;
    int countAttributes =0;
    int countMethods =0;
    int countParameters =0;
    
  void incStateMachines(){
    ++this.countStateMachines;
  }
  void incCountAssociations(){
    ++this.countAssociations;
  }  
  void incCountSubclasses() {
    ++this.countSubclasses;
  }  
  void incCountAttributes(){
    ++this.countAttributes;
  }
  void incCountMethods(){
    ++this.countMethods;
  }
  void incCountParameters(){
    ++this.countParameters;
  } 
}  


// Class that help measure data about lines
class CountLines{
  int countLines = 0; // total of lines
  int countComments = 0; // total of comment lines
  int countBlanks = 0; // total of blank lines
  int countCode = 0; // total of code line
  void incCountLines(){
    ++this.countLines;
  }
  void incCountComments(){
    ++this.countComments;
  }
  void incCountBlanks(){
    ++this.countBlanks;
  }
  void incCountCode(){
    ++this.countCode;
  }
}

class Format{
  public static String repeat(String string, int quantidade) {   
    StringBuffer retorno = new StringBuffer();   
    for (int j=0; j<quantidade; j++){   
      retorno.append(string);   
    }   
    return retorno.toString();   
  } 	
}
