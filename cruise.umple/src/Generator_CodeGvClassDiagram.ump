/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates .gv files for use by Graphviz, representing the class diagram  in the Umple model. To generate for this format, use 
  generate GvClassDiagram;
in your umple file, or the command line option
  -g GvClassDiagram

See also GvStateDiagram
 */

namespace cruise.umple.compiler;

class GvClassDiagramGenerator
{
  // Basic templates for GV elements to output
  
  // Template for what will appear at the start of each graph file
  graphStart(umpleVersion) <<!// Code generated by Umple <<=<<=umpleVersion>>>>

digraph "<<=filename>>" {
  size="80,10"
  rankdir="BT"
  node [shape=record; href="javascript:Action.selectClass(&quot;\N&quot;);"];
!>>
  emit graphStart(String filename)(graphStart(UmpleModel.VERSION_NUMBER));


  // CENTRAL GENERATE METHOD
 
  public void generate()
  {
    StringBuilder code = new StringBuilder();
    StringBuilder associations = new StringBuilder();
    String className;

    // Output basic gv file header
    _graphStart(0,code,model.getUmpleFile().getSimpleFileName());
    
    // Set of classes we are visiting
    // We always visit from the top of the hierarchy first
    // This set ensures we track what we have visited
    HashSet visitedClasses = new HashSet();

    // Iterate through each class. 
    for (UmpleClass uClass : model.getUmpleClasses())
    {
      visitClass(uClass, visitedClasses, code, associations);
    } // End iteration through classes
    
    terminateCode(code, associations);
  }

  // Actually output the class contents  
  private void visitClass(UmpleClass uClass, Set visitedClasses, StringBuilder code, StringBuilder associations)
  {
    // Ensure we only visit once
    if(visitedClasses.contains(uClass)) {
      return;
    }
    
    // Ensure  output parents in the hierarchy first
    UmpleClass parent = uClass.getExtendsClass();
    if(parent != null) {
      visitClass(parent, visitedClasses, code, associations);
    }
    visitedClasses.add(uClass);
          
    String className = uClass.getName();
    String classColor = uClass.getDisplayColor();
    if (!classColor.equals("")) classColor=" style=filled, fillcolor="+classColor+" ";
    code.append("\n  // Class: "+className+"\n");

    code.append("  \""+className+"\" ["+classColor+"shape=record, label=\"{"+className);

    if(uClass.getIsAbstract()) {  // add abstract tag
      code.append("\n&laquo;abstract&raquo;");
    }
      
    // Iterate through attributes of the class
    boolean isFirst = true;

    if (!hasSuboption("hideattributes")) { 
      for (Attribute uAttribute : uClass.getAttributes()) {
        if(isFirst) code.append("|"); // attribute block starter
        else code.append("\\\n"); // separator between attributes
        String isList = uAttribute.getIsList() ? "[]" : ""; //Hello
        String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");
        code.append(""+uAttribute.getName()+"\\ :\\ "+type+isList+"\\l");
        isFirst = false;
      }
    }
    
    if (hasSuboption("showmethods")) {
      boolean isFirstMethod = true;
      for (Method uMethod : uClass.getMethods()) {
    	if(isFirstMethod) code.append("|"); // method block starter
    	else code.append("\\\n"); // separator between attributes
    	String accessModifier = "";
    	switch (uMethod.getModifier().trim()) {
    	  case "": accessModifier = "+"; break;
    	  case "private": accessModifier = "-"; break;
    	  case "protected": accessModifier = "#"; break;
    	  case "public": accessModifier = "+"; break;
    	}
    	String parameters = "";
    	if(uMethod.hasMethodParameters()) {
    	  for (MethodParameter mp : uMethod.getMethodParameters()) {
    		parameters += mp.getFullType() + ",";
    	  }
    	  parameters = parameters.substring(0, parameters.length() - 1); // delete last comma
    	}
    	parameters = parameters.replace("<","&lt;").replace(">","&gt;");
    	String type = uMethod.getType().replace("<","&lt;").replace(">","&gt;");
    	code.append(accessModifier+uMethod.getName()+"("+parameters+")\\ :\\ "+type+"\\l");
    	isFirstMethod = false;
      }
    }

    // Terminate outputting the class attributes
    code.append("}\"");
    
    // Output the tooltip : Class name followed by any comment
    code.append(",\n   tooltip=\"class "+className+"\n");
    for (Comment uComment : uClass.getComments()) {
      String text= uComment.getText().replace("\"","\\\"");
      if(text.startsWith(" *")) {
        code.append(text.substring(2)+"\n");
      }
      else
      {
        code.append(text+"\n");
      }
    }
    code.append("\"");

    // Terminate the class as a whole
    code.append("];\n");


    // Add any generalization now to parents
    // We know that parents have been output first
    UmpleClass parentClass = uClass.getExtendsClass();
    if(parentClass!= null) {
      code.append("  \""+className+"\" -> \""+parentClass.getName()+"\"");
      code.append(" [arrowhead=\"empty\"; samehead=\"gen\"];\n\n");
    }

    // Add any interface implementations so they are output at the end
    for(UmpleInterface uInterface : uClass.getParentInterface()) {
      String intColor = uInterface.getDisplayColor();
      // TO DO needs fixing - interface colour does not appear
      if (!intColor.equals("")) {
        code.append("  \""+uInterface.getName()
          +"\" [style=filled, fillcolor="+intColor+"];\n\n ");
      } 
      code.append("  \""+className+"\" -> \""+uInterface.getName());
      code.append("\" [  arrowhead=\"empty\"; samehead=\"gen\"; style=dashed];\n\n");
    }

    // Add any associations so they are output at the end
    Set processedAssociations = new HashSet(); // needed to prevent reflexive double count
    for(Association uAssoc : uClass.getAssociations()) {
    
      // Prevent double-counting of reflexive associations
      if(processedAssociations.contains(uAssoc)) continue;
      processedAssociations.add(uAssoc);
      
      AssociationEnd leftEnd = uAssoc.getEnd(0);
      AssociationEnd rightEnd = uAssoc.getEnd(1);
      String arrows, visualArrow, visualLeftEnd, visualRightEnd,toolTip;

      // Only output them when visiting one class
      if(leftEnd.getClassName().equals(className)) {
        if(uAssoc.getIsLeftNavigable()) {
          if(uAssoc.getIsRightNavigable()) {
            arrows = "dir=\"none\"";
            visualArrow = "--";
          }
          else {
            arrows = "dir=\"back\", arrowtail=\"open\"";
            visualArrow = "<-";
          }
        }
        else if(uAssoc.getIsRightNavigable()) {
          arrows = "dir=\"forward\", arrowhead=\"open\"";
          visualArrow = "->";
        }
        else {
          arrows = "dir=\"none\"";
          visualArrow = "--";
        }

        visualLeftEnd = leftEnd.toSimpleString()+" "+leftEnd.getDisplayRoleName();
        visualRightEnd = rightEnd.toSimpleString()+" "+rightEnd.getDisplayRoleName();
        toolTip = leftEnd.getClassName() + " " + visualLeftEnd +
          " " + visualArrow + " " + visualRightEnd + " " + rightEnd.getClassName();

        associations.append("  \""+leftEnd.getClassName()+"\" -> \""+
          rightEnd.getClassName()+"\" ["+arrows+
          ", taillabel=\""+visualLeftEnd+"\""+
          ", headlabel=\""+visualRightEnd+"\""+
          ", tooltip=\""+toolTip+"\"];\n");
      }
    }
  }
  
  private void terminateCode(StringBuilder code, StringBuilder associations) {

    code.append("\n  // All associations\n");
    code.append(associations);

    code.append("}\n");

    model.setCode(code.toString());
    writeModel();
  } 

  // Used to indent code
  private void appendSpaces(StringBuilder code, int numSpaces) {
    for(int i=0; i<numSpaces; i++) {
      code.append(" ");
    }
  }

  // Output the graphviz file to a file with the .gv suffix
  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + "cd.gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz Class Diagram code." + e, e);
    }
  } 
}

