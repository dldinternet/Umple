/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates .gv files for use by Graphviz, representing the class diagram  in the Umple model. To generate for this format, use 
  generate GvClassDiagram;
in your umple file, or the command line option
  -g GvClassDiagram

See also GvStateDiagram
 */

namespace cruise.umple.compiler;

class GvClassDiagramGenerator
{
  // Basic templates for GV elements to output
  
  // Template for what will appear at the start of each graph file
  graphStart(umpleVersion) <<!// Code generated by Umple <<=<<=umpleVersion>>>>

digraph "<<=filename>>" {
  size="80,10"
  rankdir="BT"
  node [shape=record margin=0; href="javascript:Action.selectClass(&quot;\N&quot;);"];
!>>
  emit graphStart(String filename)(graphStart(UmpleModel.VERSION_NUMBER));


  // CENTRAL GENERATE METHOD
 
  public void generate()
  {
    StringBuilder code = new StringBuilder();
    StringBuilder associations = new StringBuilder();
    String className;

    // Output basic gv file header
    _graphStart(0,code,model.getUmpleFile().getSimpleFileName());
    
    // Set of classes we are visiting
    // We always visit from the top of the hierarchy first
    // This set ensures we track what we have visited
    HashSet visitedClasses = new HashSet();


    boolean manyClass = model.getUmpleClasses().size() >= 200 ? true : false;
    // Iterate through each class. 
    for (UmpleClass uClass : model.getUmpleClasses())
    {
      visitClass(uClass, visitedClasses, code, associations, manyClass);
    } // End iteration through classes
    
    terminateCode(code, associations);
  }

  // Actually output the class contents  
  private void visitClass(UmpleClass uClass, Set visitedClasses, StringBuilder code, StringBuilder associations, boolean manyClass)
  {
    // Ensure we only visit once
    if(visitedClasses.contains(uClass)) {
      return;
    }
    
    // Ensure  output parents in the hierarchy first
    UmpleClass parent = uClass.getExtendsClass();
    if(parent != null) {
      visitClass(parent, visitedClasses, code, associations, manyClass);
    }
    visitedClasses.add(uClass);
          
    String className = uClass.getName();
    classCreation(uClass, code, manyClass);

    // Add any generalization now to parents
    // We know that parents have been output first
    UmpleClass parentClass = uClass.getExtendsClass();
    if(parentClass!= null) {
      code.append("  \""+className+"\" -> \""+parentClass.getName()+"\""
      				+" [arrowhead=\"empty\"; samehead=\"gen\"];\n\n");
    }

    // Add any interface implementations so they are output at the end
    for(UmpleInterface uInterface : uClass.getParentInterface()) {
      String intColor = uInterface.getDisplayColor();
      // TO DO needs fixing - interface colour does not appear
      if (!intColor.equals("")) {
        code.append("  \""+uInterface.getName()
          +"\" [style=filled, fillcolor="+intColor+"];\n\n ");
      } 
      code.append("  \""+className+"\" -> \"    "+uInterface.getName());
      code.append("    \" [  arrowhead=\"empty\"; samehead=\"gen\"; style=dashed];\n\n");
    }

    // Add any associations so they are output at the end
    Set processedAssociations = new HashSet(); // needed to prevent reflexive double count
    for(Association uAssoc : uClass.getAssociations()) {
    
      // Prevent double-counting of reflexive associations
      if(processedAssociations.contains(uAssoc)) continue;
      processedAssociations.add(uAssoc);
      
      AssociationEnd leftEnd = uAssoc.getEnd(0);
      AssociationEnd rightEnd = uAssoc.getEnd(1);
      String modifierOne = leftEnd.getModifier();
      String modifierTwo = rightEnd.getModifier();
      String arrows, visualArrow, visualLeftEnd, visualRightEnd, toolTip, label;

      // Only output them when visiting one class
      if(leftEnd.getClassName().equals(className)) {
        if(uAssoc.getIsLeftNavigable()) {
          if(uAssoc.getIsRightNavigable()) {
            arrows = "dir=\"none\"";
            visualArrow = "--";
          }
          else {
            arrows = "dir=\"back\", arrowtail=\"open\"";
            visualArrow = "<-";
          }
        }
        else if(uAssoc.getIsRightNavigable()) {
          arrows = "dir=\"forward\", arrowhead=\"open\"";
          visualArrow = "->";
        }
        else {
          arrows = "dir=\"none\"";
          visualArrow = "--";
        }
        
        if ("symmetricreflexive".equals(modifierOne) && "symmetricreflexive".equals(modifierTwo)) 
        {
          if ("undefined".equals(rightEnd.getDisplayRoleName()))
            label = leftEnd.toSimpleString()+" "+leftEnd.getDisplayRoleName();
          else label = rightEnd.toSimpleString()+" "+rightEnd.getDisplayRoleName();
          
          toolTip = leftEnd.getClassName() + " " + label + " " + rightEnd.getClassName();
          
          associations.append("  \""+leftEnd.getClassName()+"\" -> \""+
              rightEnd.getClassName()+"\" ["+arrows+
              ", label=\""+label+"\""+
              ", tooltip=\""+toolTip+"\"];\n");
        }
        else 
        {
          visualLeftEnd = leftEnd.toSimpleString()+" "+leftEnd.getDisplayRoleName();
          visualRightEnd = rightEnd.toSimpleString()+" "+rightEnd.getDisplayRoleName();
          toolTip = leftEnd.getClassName() + " " + visualLeftEnd +
              " " + visualArrow + " " + visualRightEnd + " " + rightEnd.getClassName();
          
          associations.append("  \""+leftEnd.getClassName()+"\" -> \""+
              rightEnd.getClassName()+"\" ["+arrows+
              ", taillabel=\""+visualLeftEnd+"\""+
              ", headlabel=\""+visualRightEnd+"\""+
              ", tooltip=\""+toolTip+"\"];\n");
        }
      }
    }
  }

  private void classCreation(UmpleClass uClass, StringBuilder code, boolean manyClass)
  {
	String className = uClass.getName();
	String classColor = uClass.getDisplayColor();
    if (!classColor.equals("")) classColor=" style=filled, fillcolor="+classColor+" ";
    code.append("\n  // Class: "+className+"\n");
    
    if (manyClass) {
      code.append("  \""+className+"\" ["+classColor+"shape=record, label=\"{"+className);

	  if(uClass.getIsAbstract()) {  // add abstract tag
	    code.append("\n&laquo;abstract&raquo;");
	  }
    } 
    else {
	  code.append("  \""+className+"\" ["+classColor+"shape=plaintext margin=0 label=");
	    
	  // Different cellpadding for if the class has nothing but the
	  // name because of a glitch in graphviz's graphics
	  if ((uClass.getAttributes().size() == 0 || hasSuboption("hideattributes")) && 
	  	 (uClass.getMethods().size() == 0 || !hasSuboption("showmethods")) 
	  	 && !uClass.getIsAbstract()) {
	    code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"10\">"
		   			+"<tr><td>    "+className+"    </td></tr>");
		}
		else {
		  code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"2\">"
					  +"<tr><td cellpadding=\"4\">    "+className+"    </td></tr>");
		  }
		if(uClass.getIsAbstract()) {  // add abstract tag
		  code.append("<tr><td cellpadding=\"4\">&laquo;abstract&raquo;"+"</td></tr>");
		}
	}
    
    // Iterate through attributes of the class
    boolean isFirst = true;

    if (!hasSuboption("hideattributes")) { 
      for (Attribute uAttribute : uClass.getAttributes()) {
        if (!uAttribute.isConstant()) 
        {
          if (manyClass) {
          	if (isFirst) code.append("|"); // attribute block starter
            else code.append("\\\n"); // separator between attributes
          }
          else {
            if (isFirst) code.append("<hr/>"); // attribute block starter
          }
          String isList = uAttribute.getIsList() ? "[]" : ""; //Hello
          String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");
          
          if (manyClass) {
            code.append(""+uAttribute.getName()+"\\ :\\ "+type+isList+"\\l");
          }
          else {
            StringBuilder attrTooltip = new StringBuilder();
            attrTooltip.append(type+isList+" "+uAttribute.getName()+"&#13;");
            appendTooltipComment(attrTooltip, uAttribute.getComments(), true);          
            code.append("<tr><td align=\"left\" href=\"\" title=\""+attrTooltip+"\">"
          				+"  "+uAttribute.getName()+" : "
          				+type+isList+"  </td></tr>");
          }
          
          isFirst = false;
        }
      }
    }
    
    if (hasSuboption("showmethods")) {
      boolean isFirstMethod = true;
      for (Method uMethod : uClass.getMethods()) {
        if (manyClass) {
          if(isFirstMethod) code.append("|"); // method block starter
  		    else code.append("\\\n"); // separator between attributes
        }
        else {
    	  	if (isFirstMethod) code.append("<hr/>"); // method block starter
        }
        String accessModifier = "";
        switch (uMethod.getModifier().trim()) {
          case "": accessModifier = "+"; break;
          case "private": accessModifier = "-"; break;
          case "protected": accessModifier = "#"; break;
          case "public": accessModifier = "+"; break;
        }
        String parameters = "";
        if(uMethod.hasMethodParameters()) {
          for (MethodParameter mp : uMethod.getMethodParameters()) {
            parameters += mp.getFullType() + ",";
          }
          parameters = parameters.substring(0, parameters.length() - 1); // delete last comma
        }
        parameters = parameters.replace("<","&lt;").replace(">","&gt;");
        String type = uMethod.getType().replace("<","&lt;").replace(">","&gt;");
      
        if (manyClass) {
        	code.append(accessModifier+uMethod.getName()+"("+parameters+")\\ :\\ "+type+"\\l");
        }
        else {
        	StringBuilder methTooltip = new StringBuilder();
        	methTooltip.append(type+" "+uMethod.getName()+"("+parameters+")"+"&#13;");
        	appendTooltipComment(methTooltip, uMethod.getComments(), true);
      
        	StringBuilder hrefString = new StringBuilder();
        	hrefString.append("javascript:Action.selectMethod('");
        	hrefString.append(uMethod.getName()+"','"+type+"','"+uMethod.getModifier().trim()+"')");
         
        	code.append("<tr><td align=\"left\" href=\""+hrefString+"\" title=\""+methTooltip+"\">"
      				+"  "+accessModifier+uMethod.getName()
      				+"("+parameters+") : "+type+"  </td></tr>");
        	isFirstMethod = false;
        }
      }
    }

    // Terminate outputting the class attributes
    if(manyClass) code.append("}\"");
   	else code.append("</table>>"); 
    
    
    // Output the tooltip : Class name followed by any comment
    code.append(",\n   tooltip=\"class "+className+"\n");
    appendTooltipComment(code, uClass.getComments(), false);
    code.append("\"");

    // Terminate the class as a whole
    code.append("];\n");
	}
	
  private void terminateCode(StringBuilder code, StringBuilder associations) {

    code.append("\n  // All associations\n");
    code.append(associations);

    code.append("}\n");

    model.setCode(code.toString());
    writeModel();
  } 

  // Used to indent code
  private void appendSpaces(StringBuilder code, int numSpaces) {
    for(int i=0; i<numSpaces; i++) {
      code.append(" ");
    }
  }

  // Output the graphviz file to a file with the .gv suffix
  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + "cd.gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz Class Diagram code." + e, e);
    }
  } 
  
  // Add the comment to a tooltip
  private void appendTooltipComment(StringBuilder tooltip, List<Comment> comments, boolean title)
  {
    for (Comment uComment : comments) {
      String text;
      if (!title) {
  	  	text = uComment.getText().replace("\"","\\\"");
  	  } else {
  	    text = uComment.getText().replace("\"","'");
  	  }
  	  if(text.startsWith(" *")) {
        tooltip.append(text.substring(2)+"&#13;");
  	  }
  	  else
  	  {
        tooltip.append(text+"&#13;");
  	  }
    }
  }
}

