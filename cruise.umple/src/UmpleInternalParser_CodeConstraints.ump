/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file analyze class related umple meta model tokens such class declarations,
associations and attributes and populates the umple meta model.

Please refer to UmpleInternalParser.ump for more detailsub.

 */

namespace cruise.umple.compiler;

class UmpleInternalParser
{  

private void analyzePrecondition (Token preconditionToken, UmpleClass aClass, Method method) 
  {
    List <ConstraintVariable> cvs = analyzeConstraint(preconditionToken, aClass); //adds all identifiers to constraints
    Precondition precondition = new Precondition(method);
    
    for(ConstraintVariable cv: cvs)
    {
    	precondition.addExpression(cv);
    }  
    aClass.addPrecondition(precondition);
  }
    
  /*
   * Analyzes a token recognized as a constraint
   * 
   * @param invariantToken The token containting the constraintsub.
   * @param aClass The Umple class for which an attribute is being constrained.
   */
  private void analyzeInvariant (Token invariantToken, UmpleClass aClass)
  {
    List <ConstraintVariable> cvs = analyzeConstraint(invariantToken, aClass); //adds all identifiers to constraints
    Constraint constraint = new Constraint();
    
    for(ConstraintVariable cv: cvs)
    {
    	constraint.addExpression(cv);
    }  
    aClass.addConstraint(constraint);
  }
  
   //This recursive function parses the expression. It's very broken down to allow new features to be added easily.
  private List<ConstraintVariable> analyzeConstraint(Token invariantToken, UmpleClass aClass)
  {
    List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
    List<Token> subs = invariantToken.getSubTokens();
    for (Token t : subs)
    {
      if (t.is(")") || t.is("("))
      {
        rawLine.add(new ConstraintVariable("SYNTAX",t.getName()));
      }
      if (!t.getValue().equals("STATIC"))
      { 
        if (t.is("genExpr"))
        {
          rawLine.addAll(analyzeGeneralConstraintExpression(t,aClass));  
        }        
        else if (t.is("boolExpr"))
        {
          rawLine.addAll(analyzeBooleanConstraintExpression(t,aClass));
        } 
        else if (t.is("stringExpr"))
        {
          rawLine.addAll(analyzeStringConstraintExpression(t,aClass));
        }
        else if (t.is("numExpr"))
        {
          rawLine.addAll(analyzeNumberConstraintExpression(t,aClass));
        }
        else if(t.is("loneBoolean"))
        {
          rawLine.add(analyzeConstraintName(t,aClass,false,true,"boolean"));
        }
        else if (t.is("linkingOp")){
        	rawLine.addAll(analyzeLinkingOpExpression(t,aClass));
        }
        else if (t.is("negativeConstraint")){
        	rawLine.addAll(analyzeNegativeConstraint(t, aClass));
        }
        else
        {
          rawLine.addAll(analyzeConstraint(t,aClass));
        }
      } 
    }
  return rawLine;
  }
  
  private List <ConstraintVariable> analyzeNegativeConstraint(Token negativeConstraintToken, UmpleClass aClass){
	  List<Token> negativeConstraintSubtokens = negativeConstraintToken.getSubTokens();
	  List <Token> subtokensCopy = new ArrayList <Token> ();
	  subtokensCopy.addAll(negativeConstraintSubtokens);
	  
	  List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
	 
	  rawLine.add(new ConstraintVariable("OPERATOR","!"));
	  rawLine.add(new ConstraintVariable("SYNTAX","("));
	 
	  for (Token s :subtokensCopy){
		   String name = s.getName();
	      	if (name.equals("!")|name.equals("not")|name.equals("~")){
	      		negativeConstraintToken.removeSubToken(s);	
	      	}
	      }
	  
	  rawLine.addAll(analyzeConstraint(negativeConstraintToken, aClass)); 
	  
	  rawLine.add(new ConstraintVariable("SYNTAX",")"));

	  return rawLine; //rawLine = !(constraintBodystuff)
  }
  
  private List<ConstraintVariable> analyzeLinkingOpExpression(Token linkingOpExpressionToken , UmpleClass aClass)
  {
	  List<Token> LinkingOpExpressionSubtokens = linkingOpExpressionToken.getSubTokens();
	  List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
	  
	  Token subOp = LinkingOpExpressionSubtokens.get(0); //the linking Expr (ie) &&, ||
	  
	
	  if (subOp.is("||")||subOp.is("orOp"))
	  {
		  rawLine.add(new ConstraintVariable("OPERATOR","||"));
	  } 
	  else if (subOp.is("andOp"))
	  {
		  rawLine.add(new ConstraintVariable("OPERATOR","&&"));
	  }
	  
	  Token subExpr = LinkingOpExpressionSubtokens.get(1); //the constraintExpr token
	  Token dummyToken = new Token ("dummyToken", null); //need to encapsulate constrainExpr in dummy token
	  dummyToken.addSubToken(subExpr);
	  rawLine.addAll(analyzeConstraint(dummyToken, aClass)); 

	  return rawLine;

  }
  private List<ConstraintVariable> analyzeGeneralConstraintExpression(Token generalExpressionToken, UmpleClass aClass)
  {
	List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
	List<Token> generalExpressionSubtokens = generalExpressionToken.getSubTokens();
    for(Token sub : generalExpressionSubtokens)
    {
      if (sub.getValue().equals("STATIC"))
      {
        if(!sub.is("}")&&!sub.is("{")&&!sub.is("[")&&!sub.is("]")&&!sub.is("\'")&&!sub.is("\""))
          rawLine.add(new ConstraintVariable("SYNTAX",sub.getName()));
      } 
      else if(sub.is("name"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,true,true));
      } 
      else if(sub.is("tail"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,true,false));
      } 
      else if(sub.is("index"))
      {
        analyzeConstraintIndex(sub,rawLine.get(rawLine.size()-2));
      }
      else if(sub.is("equalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","=="));
      }
      else if(sub.is("notequalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","!="));
      }
    }
    return rawLine;
  }
  
  private List<ConstraintVariable> analyzeBooleanConstraintExpression(Token booleanExpressionToken , UmpleClass aClass)
  {
  	List<Token> BooleanExpressionSubtokens = booleanExpressionToken.getSubTokens();
  	List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
  	for(Token sub : BooleanExpressionSubtokens)
    {
      if (sub.getValue().equals("STATIC"))
      {
        if(!sub.is("}")&&!sub.is("{")&&!sub.is("[")&&!sub.is("]")&&!sub.is("\'")&&!sub.is("\""))
          rawLine.add(new ConstraintVariable("SYNTAX",sub.getName()));
      }
      else if (sub.getValue().equals("true"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","true"));
      } 
      else if (sub.getValue().equals("false"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","false"));
      }
      else if(sub.is("name"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,false,true,"boolean"));
      }
      else if(sub.is("index"))
      {
        analyzeConstraintIndex(sub,rawLine.get(rawLine.size()-2));
      }
      else if(sub.is("equalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","=="));
      }
      else if(sub.is("notequalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","!="));
      }           
    }
    return rawLine;
  }
  
  private List<ConstraintVariable> analyzeStringConstraintExpression(Token stringExpressionToken , UmpleClass aClass)
  {
  	List<Token> stringExpressionSubtokens = stringExpressionToken.getSubTokens();
  	List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
  	for(Token sub : stringExpressionSubtokens)
    {
      if (sub.getValue().equals("STATIC"))
      {
        if(!sub.is("}")&&!sub.is("{")&&!sub.is("[")&&!sub.is("]")&&!sub.is("\'")&&!sub.is("\""))
          rawLine.add(new ConstraintVariable("SYNTAX",sub.getName()));
      }
      else if (sub.is("quote"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","\""+sub.getValue()+"\""));
      }
      else if(sub.is("name"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,false,true,"string"));
      }
      else if(sub.is("index"))
      {
        analyzeConstraintIndex(sub,rawLine.get(rawLine.size()-2));
      }
      else if(sub.is("equalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","=="));
      }
      else if(sub.is("notequalsOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","!="));
      }           
    }
    return rawLine;
  }
  
  private List<ConstraintVariable> analyzeNumberConstraintExpression(Token numberExpressionToken, UmpleClass aClass)
  {
	List<ConstraintVariable> rawLine = new ArrayList<ConstraintVariable>();
	List<Token> numberExpressionSubtokens = numberExpressionToken.getSubTokens();
    for(Token sub : numberExpressionSubtokens)
    {
      if (sub.getValue().equals("STATIC"))
      {
      	if(!sub.is("}")&&!sub.is("{")&&!sub.is("[")&&!sub.is("]")&&!sub.is("\'")&&!sub.is("\""))
          rawLine.add(new ConstraintVariable("SYNTAX",sub.getName()));
      } 
      else if(sub.is("name"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,true,true,"integer","float","double"));
      } 
      else if(sub.is("tail"))
      {
        rawLine.add(analyzeConstraintName(sub,aClass,true,false));
      } 
      else if(sub.is("index"))
      {
        analyzeConstraintIndex(sub,rawLine.get(rawLine.size()-2));
      }
      else if(sub.is("moreOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR",">"));
      }
      else if(sub.is("smallerOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","<"));
      }
      else if(sub.is("greaterOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR",">="));
      }
      else if(sub.is("lessOp"))
      {
        rawLine.add(new ConstraintVariable("OPERATOR","<="));
      }
    }
    return rawLine;
  }
  
   private ConstraintVariable analyzeConstraintName(Token nameToken, UmpleClass aClass, boolean canBeInteger, boolean mustBeInClass, String... type)
  {
  	Token sub = nameToken;
  	Token grandparentToken = sub.getParentToken().getParentToken();
  	ConstraintVariable cv = new ConstraintVariable("",sub.getValue());
  	UmpleVariable attribute;
    if(mustBeInClass)
    {
      attribute = cv.getAttribute(aClass);
      if(attribute!=null)
      {
      	if(type!=null&&type.length!=0)
      	{
      	  boolean isType = false;
      	  String typesFailed = "";
      	  for(String t: type)
      	  {
      	    if(attribute.getType().toLowerCase().equals(t))
            {
              isType = true;
            }          
            else
            {
            	typesFailed += t+",";
            }
          }
          if(!isType)
          {
          	setFailedPosition(sub.getPosition(), 29, sub.getValue(), typesFailed);
          }
        }
        cv.setType(attribute.getType());
      }
      
      else if (grandparentToken.getName().equals("precondition")){ //if it was a precondition, check if it matches any of the method arguments
    	  Token concreteMethod = grandparentToken.getParentToken();
    	  ArrayList <MethodParameter> methodparams = new ArrayList <MethodParameter>();
    	  for (Token t : concreteMethod.getSubTokens()){
    		  if (t.getName().equals("methodDeclarator")){
    			  for (Token st : t.getSubTokens()){
    				  if (st.getName().equals("parameterList")){
    					  for (Token sst : st.getSubTokens()){
    						   if(sst.getName().equals("parameter")){
    							   String paramName = null;
    							   String paramType = null;
    							   for (Token ssst: sst.getSubTokens()){
    								   if (ssst.getName().equals("type")){
    									   paramType = ssst.getValue();
    								   }
    								   if (ssst.getName().equals("name")){
    									   paramName = ssst.getValue();
    								   }
    							   }
    							   MethodParameter mp = new MethodParameter(paramName, paramType, null, null, false);
    							   methodparams.add(mp);
    						   }
    					  }
    				  }
    			  }
    		  }
    	  }
    	  boolean matchesAnyMethodParams = false;
    	  for (MethodParameter mp : methodparams){ 
    		  if (mp.getName().equals(sub.getValue())){
    			  matchesAnyMethodParams = true; 
    			  cv.setType(mp.getType());
    		  }
    	  }

    	  if (!matchesAnyMethodParams){
    		  analyzeConstraintName_CanBeInteger(canBeInteger, sub, cv);
    	  } 
      }
      
      else
      {
    	analyzeConstraintName_CanBeInteger(canBeInteger, sub, cv);
      }
    }
    else
    {
      if(canBeInteger)
      {
        try {
      	  Integer.parseInt(sub.getValue());
            cv.setType("OPERATOR");
          } catch (NumberFormatException e) {
            setFailedPosition(sub.getPosition(), 28, sub.getValue(), sub.getName());
          } 
      }
      else
      {
      	cv.setType("OPERATOR");      
      }      
    }    
    return cv;
  }
  private void analyzeConstraintName_CanBeInteger(boolean canBeInteger, Token sub, ConstraintVariable cv){
	  if(canBeInteger)
      {
        try {
    	    Integer.parseInt(sub.getValue());
            cv.setType("OPERATOR");
          } catch (NumberFormatException e) {
            setFailedPosition(sub.getPosition(), 28, sub.getValue(), sub.getName());
          } 
      }
      else
      {
  	  setFailedPosition(sub.getPosition(), 28, sub.getValue(), sub.getName());
  	}
  }
  private void analyzeConstraintIndex(Token indexToken, ConstraintVariable cv)
  {
  	Token sub = indexToken;
  	try {
      int i = Integer.parseInt(sub.getValue());
      if(cv.getIsAssociation())
      {
        cv.setIndex(i);
      }
      else
      {
        setFailedPosition(sub.getPosition(), 29, cv.getValue(), "association or list");
      }
    } catch (NumberFormatException e) {
      setFailedPosition(sub.getPosition(), 29, sub.getValue(), "integer");
    } 
  	   
  }   
}
