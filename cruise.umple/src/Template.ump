/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Template meta-model.

*/

//@author Ahmed M.Orabi {@link ahmedvc@hotmail.com}
//@author Mahmoud M.Orabi {@link mahmoud_3rabi@hotmail.com}
namespace cruise.umple.compiler;

//Handle the existing templates in the current umple model.
/*
class UmpleModel {
  UmpleTemplate getUmpleTemplate(String name){
    for (UmpleTemplate aTemplate : getUmpleTemplates())
    {
      if (aTemplate.getName().equals(name))
      {
        return aTemplate;
      }
    }
    return null;
  }
  
   public UmpleTemplate addUmpleTemplate(String name)
  {
    UmpleTemplate newTemplate = getUmpleTemplate(name);
    if (newTemplate == null)
    {
      newTemplate = new UmpleTemplate(name, this);
      addUmpleTemplate(newTemplate);
    }
    return newTemplate;
  }
}
*/

//----------------------------------------------------------
//An umple template contains a map for emittable strings
class UmpleClass {	
	depend java.util.*;
	int templateFieldCount = 0;
	lazy TemplateMethod [] emitMethods;
	0..1 -- * TemplateField templateFields;
	
	Map<String,TemplateAttributeParser> templateEmitStringMap = new HashMap<String,TemplateAttributeParser>();
}

class TemplateName {
  String name;
  String[] parameters;
}

class TemplateMethodBlock {
  Position position;
  String template;
  String[] parameters;
}

//Method rpesentations in a template 
class TemplateMethod {
	Method method;
	lazy TemplateMethodBlock [] templates;
}

//A template filed reprsents a field with a value for emitting purposes
class TemplateField {
	const String TEMPLATE_TEXT_FIELD="TEXT_";
	String name;
	EmitResponse value;
}

class EmitResponse {
	StringBuilder javaCode = new StringBuilder();
	StringBuilder cppCode = new StringBuilder();
	
	StringBuilder getCode(String lang) {
		if(lang.equalsIgnoreCase("Java")) {  
  			return javaCode;
  		} else if(lang.equalsIgnoreCase("Cpp")) {
  			return cppCode;     
	  	}
	  	return null;
	}
}

//A template element represents template contents to be built. It relies on a set of TemplateField
class TemplateElement
{
  abstract;
  lazy internal EmitResponse emitResponse;
  String content; 

  0..1 -- * TemplateField fields;
  0..1 parentElement -- * TemplateElement subElements;

  after constructor {
    emitResponse = new EmitResponse();
    getEmitResponse().getJavaCode().append(content);
    getEmitResponse().getCppCode().append(content);
  }

  EmitResponse computeContent(){
    EmitResponse old = getEmitResponse();
    emitResponse = new EmitResponse();
    getEmitResponse().getJavaCode().append(old.getJavaCode());
    getEmitResponse().getCppCode().append(old.getCppCode());
    for(TemplateElement element:getSubElements())
    {
      EmitResponse resetValue = element.computeContent();
      getEmitResponse().getJavaCode().append(element.getEmitResponse().getJavaCode().toString());
      getEmitResponse().getCppCode().append(element.getEmitResponse().getCppCode().toString());
      element.resetContent(resetValue);
    }
    return old;
  }

  after setContent
  {
    emitResponse = new EmitResponse();
    getEmitResponse().getJavaCode().append(content);
    getEmitResponse().getCppCode().append(content);
  }

  void resetContent(EmitResponse old)
  {
    emitResponse = old;
  }	
  
  void append(String text)
  {
    getEmitResponse().getJavaCode().append(text);
    getEmitResponse().getCppCode().append(text);
  }
 
  EmitResponse getEmitResponse()
  {
     return emitResponse;
  }
  
  List<TemplateField> emit(EmitResponse responseBuffer, int idx) { return new ArrayList<TemplateField>(); }
	
}

//Expression segment in a template
class ExpressionElement {
	isA TemplateElement;	
	
	
	List<TemplateField> emit(EmitResponse responseBuffer, int idx) 
	{
	  EmitResponse resetValue = computeContent();
      responseBuffer.getJavaCode().append("    ");      
      Utils.getStringAppend("Java", responseBuffer.getJavaCode(), getEmitResponse().getJavaCode().toString());
	  responseBuffer.getJavaCode().append(System.getProperty("line.separator"));

	  responseBuffer.getCppCode().append("    ");
      Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), getEmitResponse().getCppCode().toString());
	  responseBuffer.getCppCode().append(System.getProperty("line.separator"));
          resetContent(resetValue);
	  return super.emit(responseBuffer, idx);
	}
}

//Scriplet segment in a template
class CodeBlockElement {
	isA TemplateElement;

	List<TemplateField> emit(EmitResponse responseBuffer, int idx) {
	    EmitResponse resetValue = computeContent();
	
		responseBuffer.getJavaCode().append("    ");
		responseBuffer.getJavaCode().append(getEmitResponse().getJavaCode());
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));
		
		
		responseBuffer.getCppCode().append("    ");
		responseBuffer.getCppCode().append(getEmitResponse().getCppCode());
		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		
            resetContent(resetValue);
		return super.emit(responseBuffer, idx);
	}
}

//Comment segment for a template contents
class CommentElement {
	isA TemplateElement;
	
	int index = -1;
	
	List<TemplateField> emit(EmitResponse responseBuffer, int idx) {
	    boolean first = false;
	    if(getIndex()==-1)
	    {
	      setIndex(idx);
	      first = true;
	    }
		String fieldId = TemplateField.TEMPLATE_TEXT_FIELD + getIndex();
		EmitResponse fieldValue = new EmitResponse();
		String javaContent = getEmitResponse().getJavaCode().toString();		
		javaContent = "/*" + javaContent + "*/";
		
		String cppContent = getEmitResponse().getCppCode().toString();
		cppContent = "/*" + cppContent + "*/";
		
		fieldValue.getJavaCode().append(Utils.nlize("Java", javaContent));
		fieldValue.getCppCode().append(Utils.nlize("Cpp", cppContent));
				
        if(first)
        {
		  addField(new TemplateField(fieldId, fieldValue));
		}
		
		
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), fieldId);
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));

		responseBuffer.getCppCode().append("    ");		
		Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), fieldId);
		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		
		if(first)
		{
		  return getFields();
		}
		else
		{
		  return super.emit(responseBuffer, idx);
		}
	}
}

class TextElement {
	isA TemplateElement;

    int index = -1;

	List<TemplateField> emit(EmitResponse responseBuffer, int idx) {
	  boolean first = false;
	    if(getIndex()==-1)
	    {
	      setIndex(idx);	
	      first = true;
	    }      
	    
		String fieldId = TemplateField.TEMPLATE_TEXT_FIELD + getIndex();
		EmitResponse fieldValue = new EmitResponse();
		String javaContent = getEmitResponse().getJavaCode().toString();
		String cppContent = getEmitResponse().getCppCode().toString();	
		
		fieldValue.getJavaCode().append(Utils.nlize("Java", javaContent));
		fieldValue.getCppCode().append(Utils.nlize("Cpp", cppContent));
		
		if(first)
		{
	      addField(new TemplateField(fieldId, fieldValue));
		}
		
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), fieldId);
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));

		responseBuffer.getCppCode().append("    ");		
        Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), fieldId);
		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		
		if(first)
		{
		  return getFields();
		}
		else
		{
		  return super.emit(responseBuffer, idx);
		}
	}
}

class VariableElement {
	isA TemplateElement;

    int index;

	List<TemplateField> emit(EmitResponse responseBuffer, int idx) {
		String fieldId = TemplateField.TEMPLATE_TEXT_FIELD + idx;
		EmitResponse fieldValue = new EmitResponse();
		String javaContent = getEmitResponse().getJavaCode().toString();
		String cppContent = getEmitResponse().getCppCode().toString();	
		
		fieldValue.getJavaCode().append(Utils.nlize("Java", javaContent));
		fieldValue.getCppCode().append(Utils.nlize("Cpp", cppContent));
				
		if(numberOfFields()>0){
		  removeField(getField(0));
		}
		addField(new TemplateField(fieldId, fieldValue));
		
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), fieldId);
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));

		responseBuffer.getCppCode().append("    ");		
		Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), fieldId);
		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		
		return getFields();
	}
}

interface MethodTemplateFormatter {
	String getPrimaryEmitMethodBody(String methodName, String params);
	String getSecondaryEmitMethodBody(EmitResponse emitResp);
}

class JavaMethodTemplateFormatter {
	isA MethodTemplateFormatter;
	
	String getPrimaryEmitMethodBody(String methodName, String params) {
		return getJavaPrimaryEmitMethodBody(methodName, params);
	}
	String getSecondaryEmitMethodBody(EmitResponse emitResp) {
		return getJavaSecondaryEmitMethodBody(emitResp);
	}
	
	String emit getJavaSecondaryEmitMethodBody(EmitResponse emitResp)(javaSecondaryEmitMethodBody);
	javaSecondaryEmitMethodBody <<!String spaces="";
    StringBuilder newCode = new StringBuilder();
    StringBuilder realSb = sb;
    if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode.append(spaces);
    }
    
<<=emitResp.getCode("Java")>>
    if(numSpaces > 0) {
        newCode.replace(0, newCode.length(), Pattern.compile(NL).matcher(newCode).replaceAll(NL + spaces));
        sb.append(newCode);
    }
    return sb; !>>
	
	String emit getJavaPrimaryEmitMethodBody(String methodName, String params)(javaPrimaryEmitMethod);
  	javaPrimaryEmitMethod <<!		StringBuilder sb = new StringBuilder();
		return this.<<=methodName>>(<<=params>>).toString(); !>>	
}

class CppMethodTemplateFormatter {
	isA MethodTemplateFormatter;
	
	String getPrimaryEmitMethodBody(String methodName, String params) {
		return getCppPrimaryEmitMethodBody(methodName, params);
	}
	String getSecondaryEmitMethodBody(EmitResponse emitResp) {
		return getCppSecondaryEmitMethodBody(emitResp);
	}
	
	
	String emit getCppSecondaryEmitMethodBody(EmitResponse emitResp)(cppSecondaryEmitMethodBody);
	cppSecondaryEmitMethodBody <<!string spaces = "";
	string newCode = "";
	string realSb = sb;
	if(numSpaces > 0) {
        realSb = newCode;
        spaces = _createSpacesString(numSpaces);
        newCode+=spaces;
    }
    
<<=emitResp.getCode("Cpp")>>
    if(numSpaces > 0) {
        string replacement = NL + spaces;
        for(string::size_type _szIdx_ = 0; (_szIdx_ = newCode.find(NL, _szIdx_)) != string::npos;newCode.replace(_szIdx_, NL.length(), replacement),_szIdx_ += replacement.length() - NL.length() + 1);
        sb+=newCode;
    }
    return sb; !>>
	
	String emit getCppPrimaryEmitMethodBody(String methodName, String params)(cppPrimaryEmitMethod);
  	cppPrimaryEmitMethod <<!		string sb;
		return this-><<=methodName>>(<<=params>>); !>>
}

//Helpr class to handle the process of emiitting the code to its eqivalent in JET based
//on the existing template elements and their contents, expressions, etc.
class Utils {
	depend java.util.regex.Matcher;
	depend java.util.regex.Pattern;	
	singleton;
	
	private static Pattern newLinePattern = Pattern.compile("([\\n][\\r]?|[\\r][\\n]?)", Pattern.MULTILINE);
	
	// TODO : Replace with array which cover all umple language codeblocks
	private static MethodTemplateFormatter javaTemplateFormatter = new JavaMethodTemplateFormatter();
	private static MethodTemplateFormatter cppTemplateFormatter = new CppMethodTemplateFormatter();
	
	
	public static boolean isBlank(String str) {
		int len = str == null ? 0 : str.length();
		if (len == 0) {
			return true;
		}
	    for (int i = 0; i < len; i++) {
	    	if (!Character.isWhitespace(str.charAt(i)))
	    		return false;
	    }
	    return true;
	}
	
	// JET Style
	public static String nlize(String lang, String str) {
	  StringBuilder result = new StringBuilder(str.length());
	  Matcher m = newLinePattern.matcher(str);
	  if(m.find()) {
		  int currentIndex = 0;
		  boolean first = true;
		  do{
			  if(first) {
				  first = false;
			  } else {
				  result.append(Utils.getStringConcat(lang)); 
			  }
			  if(m.start() > currentIndex) {
			  	  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("string(\"");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
				  
				  result.append(Utils.escapeString(str.substring (currentIndex, m.start())));
				  
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("\")");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
				  result.append(Utils.getStringConcat(lang)); 
			  }
			  result.append(Utils.getLineSeparator());
			  currentIndex = m.end();
		  } while( m.find());
		  if(currentIndex < str.length()) {
			  if(!first) {
				  result.append(Utils.getStringConcat(lang));
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("string(\"");		  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
			  	  
				  result.append(Utils.escapeString(str.substring(currentIndex)));
				  
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("\")");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
			  }
		  }
		  return result.toString();
	  } else {
		  result.append('"');
		  result.append(Utils.escapeString(str));
		  result.append('"');
		  return result.toString();
	  }
  	}
  	
  	public static String getLineSeparatorValue(String lang) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			return "System.getProperty(\"line.separator\")";
  		} else if(lang.equalsIgnoreCase("Cpp")) {  
//	    	return "endl";
			return "string(\"\\n\")";
	  	}
	  	return "\n";
	 }
  	
  	public static String getLineSeparator() {
  		return "NL";
	 }
	
	public static String getStringConcat(String lang) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			return " + ";  
  		} else if(lang.equalsIgnoreCase("Cpp")) {  
	    	return " + ";  
	  	}
	  	return "";
	 }
	
	public static MethodTemplateFormatter getMethodTemplateFormatter(String lang) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			return javaTemplateFormatter; 
  		} else if(lang.equalsIgnoreCase("Cpp")) {  
  			return cppTemplateFormatter;
	  	}
	  	// TODO : Unspecified Lang code handler
	  	return null; 
  	}
	  	
  	
  	public static void getStringAppend(String lang, StringBuilder sb, String value) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			sb.append("realSb.append(");
  			sb.append(value);
  			sb.append(");");
  		} else if(lang.equalsIgnoreCase("Cpp")) {  
//	    	sb.append("sb << ");
	    	sb.append("realSb+= ");
  			sb.append(value);
  			sb.append(";");
	  	}
  	}

	 /*
	  public static String trimTemplateBlockNewLines(String str) {
        int end = str.length;
        int start = 0;
        while ((start < end) && (str.charAt(start) == '\n')) {
            start++;
        }
        while ((start < end) && (str.charAt(end - 1) == '\n')) {
        	end--;
        }
        if (str.charAt(end-1) == '\r') {
        	end--;
        }
        return ((start > 0) || (end < str.length)) ? str.substring(start, end) : str;
    	}
    */
	 
	  public static String trimTemplateBlockBeginigNewLine(String str) {
	  	Pattern spacesNewLinePattern = Pattern.compile("\\s*([\\n][\\r]?|[\\r][\\n]?)", Pattern.MULTILINE);
	  	Matcher m = spacesNewLinePattern.matcher(str);
	  	return (m.find()) ? str.substring(m.end()) : str;
      }
    
     public static String trimTemplateBlockEndNewLine(String str) {
	  	Pattern endSpacesNewLinePattern = Pattern.compile("([\\n][\\r]?|[\\r][\\n]?)\\s*$", Pattern.MULTILINE);
	  	Matcher m = endSpacesNewLinePattern.matcher(str);
	  	return (m.find()) ? str.substring(0,m.start() + 1) : str;
      }
	
  	
	public static String escapeString(String str) {
		return str.replaceAll("\n", "\\\\n")
				  .replaceAll("\r", "\\\\r")
				  .replaceAll("\t", "  ") // Two spaces instead of tab
				  .replaceAll("\\\\", "\\\\\\\\")
				  .replaceAll("\b", "\\\\b")
				  .replaceAll("\f", "\\\\f")
				  .replaceAll("\'", "\\\'")
				  .replaceAll("\"", "\\\"")
				  .replace("\"","\\\"");
	}
}


//use Template_Code.ump;
