/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Template meta-model.

*/

//@author Ahmed M.Orabi {@link ahmedvc@hotmail.com}
//@author Mahmoud M.Orabi {@link mahmoud_3rabi@hotmail.com}
namespace cruise.umple.compiler;

//Handle the existing templates in the current umple model.
class UmpleModel {
  UmpleTemplate getUmpleTemplate(String name){
    for (UmpleTemplate aTemplate : getUmpleTemplates())
    {
      if (aTemplate.getName().equals(name))
      {
        return aTemplate;
      }
    }
    return null;
  }
  
   public UmpleTemplate addUmpleTemplate(String name)
  {
    UmpleTemplate newTemplate = getUmpleTemplate(name);
    if (newTemplate == null)
    {
      newTemplate = new UmpleTemplate(name, this);
      addUmpleTemplate(newTemplate);
    }
    return newTemplate;
  }
}

//----------------------------------------------------------
//An umple template contains a map for emittable strings
class UmpleTemplate {
	depend java.util.*;
	int templateFieldCount = 0;
	Map<String,EmitResponse> templateEmitStringMap = new HashMap<String,EmitResponse>();
}

//A template filed reprsents a field with a value for emitting purposes
class TemplateField {
	const String TEMPLATE_TEXT_FIELD="TEXT_";
	String name;
	EmitResponse value;
}

class EmitResponse {
	StringBuilder javaCode = new StringBuilder();
	StringBuilder cppCode = new StringBuilder();
}

//A template element represents template contents to be built. It relies on a set of TemplateField
class TemplateElement {
	abstract;
	lazy internal EmitResponse emitResponse;
	internal String content; 
	
	0..1 -- * TemplateField fields;

	after constructor {
		emitResponse = new EmitResponse();
		getEmitResponse().getJavaCode().append(content);
		getEmitResponse().getCppCode().append(content);
	}
	void append(String text) {
		getEmitResponse().getJavaCode().append(text);
		getEmitResponse().getCppCode().append(text);
	}
	EmitResponse getEmitResponse() {
		return emitResponse;
	}
	void emit(EmitResponse responseBuffer, int idx) {}
}

//Expression segment in a template
class ExpressionElement {
	isA TemplateElement;
	
	void emit(EmitResponse responseBuffer, int idx) {
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), getEmitResponse().getJavaCode().toString());

		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		responseBuffer.getCppCode().append("    ");		
		Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), getEmitResponse().getCppCode().toString());
	}
}

//Scriplet segment in a template
class ScripletElement {
	isA TemplateElement;

	void emit(EmitResponse responseBuffer, int idx) {
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));
		responseBuffer.getJavaCode().append("    ");
		responseBuffer.getJavaCode().append(getEmitResponse().getJavaCode());
		
		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		responseBuffer.getCppCode().append("    ");
		responseBuffer.getCppCode().append(getEmitResponse().getCppCode());

	}
}

//Comment segment for a template contents
class CommentElement {
	isA TemplateElement;
	void emit(EmitResponse responseBuffer, int idx) {
		String fieldId = TemplateField.TEMPLATE_TEXT_FIELD + idx;
		EmitResponse fieldValue = new EmitResponse();
		String javaContent = getEmitResponse().getJavaCode().toString();		
		javaContent = "/*" + javaContent + "*/";
		
		String cppContent = getEmitResponse().getCppCode().toString();
		cppContent = "/*" + cppContent + "*/";
		
		fieldValue.getJavaCode().append(Utils.nlize("Java", javaContent));
		fieldValue.getCppCode().append(Utils.nlize("Cpp", cppContent));
				
		addField(new TemplateField(fieldId, fieldValue));
		
		
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), fieldId);

		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		responseBuffer.getCppCode().append("    ");		
		Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), fieldId);
	}
}

class TextElement {
	isA TemplateElement;

	void emit(EmitResponse responseBuffer, int idx) {
		String fieldId = TemplateField.TEMPLATE_TEXT_FIELD + idx;
		EmitResponse fieldValue = new EmitResponse();
		String javaContent = getEmitResponse().getJavaCode().toString();
		String cppContent = getEmitResponse().getCppCode().toString();	
		
		fieldValue.getJavaCode().append(Utils.nlize("Java", javaContent));
		fieldValue.getCppCode().append(Utils.nlize("Cpp", cppContent));
				
		addField(new TemplateField(fieldId, fieldValue));
		
		responseBuffer.getJavaCode().append(System.getProperty("line.separator"));
		responseBuffer.getJavaCode().append("    ");		
		Utils.getStringAppend("Java", responseBuffer.getJavaCode(), fieldId);

		responseBuffer.getCppCode().append(System.getProperty("line.separator"));
		responseBuffer.getCppCode().append("    ");		
		Utils.getStringAppend("Cpp", responseBuffer.getCppCode(), fieldId);
	}
}

//Helpr class to handle the process of emiitting the code to its eqivalent in JET based
//on the existing template elements and their contents, expressions, etc.
class Utils {
	depend java.util.regex.Matcher;
	depend java.util.regex.Pattern;
	
	singleton;
	public static boolean isBlank(String str) {
		int len = str == null ? 0 : str.length();
		if (len == 0) {
			return true;
		}
	    for (int i = 0; i < len; i++) {
	    	if (!Character.isWhitespace(str.charAt(i)))
	    		return false;
	    }
	    return true;
	}
	
	// JET Style
	public static String nlize(String lang, String str) {
	  StringBuilder result = new StringBuilder(str.length());
	  Pattern newLinePattern = Pattern.compile("([\\n][\\r]?|[\\r][\\n]?)", Pattern.MULTILINE);
	  Matcher m = newLinePattern.matcher(str);
	  if(m.find()) {
		  int currentIndex = 0;
		  boolean first = true;
		  do{
			  if(first) {
				  first = false;
			  } else {
				  result.append(Utils.getStringConcat(lang)); 
			  }
			  if(m.start() > currentIndex) {
			  	  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("string(\"");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
				  
				  result.append(Utils.escapeString(str.substring (currentIndex, m.start())));
				  
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("\")");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
				  result.append(Utils.getStringConcat(lang)); 
			  }
			  result.append(Utils.getLineSeparator());
			  currentIndex = m.end();
		  } while( m.find());
		  if(currentIndex < str.length()) {
			  if(!first) {
				  result.append(Utils.getStringConcat(lang));
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("string(\"");		  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
			  	  
				  result.append(Utils.escapeString(str.substring(currentIndex)));
				  
				  if(lang.equalsIgnoreCase("Cpp")) {
			  	  	result.append("\")");			  	  	
			  	  } else {
			  	  	result.append('"');
			  	  }
			  }
		  }
		  return result.toString();
	  } else {
		  result.append('"');
		  result.append(Utils.escapeString(str));
		  result.append('"');
		  return result.toString();
	  }
  	}
  	
  	public static String getLineSeparatorValue(String lang) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			return "System.getProperty(\"line.separator\")";
  		} if(lang.equalsIgnoreCase("Cpp")) {  
//	    	return "endl";
			return "string(\"\\n\")";
	  	}
	  	return "\n";
	 }
  	
  	public static String getLineSeparator() {
  		return "NL";
	 }
	
	public static String getStringConcat(String lang) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			return " + ";  
  		} if(lang.equalsIgnoreCase("Cpp")) {  
	    	return " + ";  
	  	}
	  	return "";
	 }
	
	public static void getWrapMethodReturnSignature(String lang,StringBuilder sb) {
		if(lang.equalsIgnoreCase("Java")) {  
  			sb.append("return sb;");  
  		} if(lang.equalsIgnoreCase("Cpp")) {
  			sb.append("return sb;");  
	  	}
	}
	
	public static void getStringBuilderToString(String lang,StringBuilder sb, String mthName, String paramSignature) {
		if(lang.equalsIgnoreCase("Java")) {
			sb.append("    ");
			sb.append("return ");
			sb.append("this.");
			sb.append(mthName);
			sb.append("(");
			sb.append(paramSignature);
			sb.append(").toString();");  
//			sb.append(System.getProperty("line.separator"));  
  		} if(lang.equalsIgnoreCase("Cpp")) { 
  			sb.append("    ");
  			sb.append("return ");
			sb.append("this->");
			sb.append(mthName);
			sb.append("(");
			sb.append(paramSignature);
			sb.append(");");  
//	    	sb.append("return sb.str();");
//			sb.append(System.getProperty("line.separator"));  
	  	}
	}
  	
  	public static void getStringAppend(String lang, StringBuilder sb, String value) {
  		if(lang.equalsIgnoreCase("Java")) {  
  			sb.append("sb.append(");
  			sb.append(value);
  			sb.append(");");
  		} if(lang.equalsIgnoreCase("Cpp")) {  
//	    	sb.append("sb << ");
	    	sb.append("sb+= ");
  			sb.append(value);
  			sb.append(";");   
	  	}
  	}
  	public static void getStringBuilder(String lang, StringBuilder sb){
	  	if(lang.equalsIgnoreCase("Java")) {  
  			sb.append("StringBuilder sb = new StringBuilder();");
  		} if(lang.equalsIgnoreCase("Cpp")) {  
//  			sb.append("std::stringstream sb;");
  			sb.append("string sb;");     
	  	}
	 }
  	
	public static String escapeString(String str) {
		return str.replaceAll("\n", "\\\\n")
				  .replaceAll("\r", "\\\\r")
				  .replaceAll("\t", "  ") // Two spaces instead of tab
				  .replaceAll("\b", "\\\\b")
				  .replaceAll("\f", "\\\\f")
				  .replaceAll("\"", "\\\\\"");
	}
}



//use Template_Code.ump;