/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

Code for methods mixed into the UmpleSync.ump model

*/

namespace cruise.umple.sync;

class SynchronizationAction
{  
  public void go()
  {
  
  }
}

class UpdatePositioningAction
{
  
  public void go()
  {
    try
    {
      textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for debug
        //textParser.insert("//Unable to update umple code due to error at " + result.getPosition());
        //setUmpleCode(textParser.getText());
        //return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for debug
        //textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        //setUmpleCode(textParser.getText());
        //return;
      }
      
      jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        //Uncomment for debug
        //uncomment for testing purposes
        //setUmpleCode("//****Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      
      json = jsonParser.analyze();
      verifySubClasses(umpleParser.getRootToken());
      
    }
    catch (Exception e)
    {
      handleException(e, "yo5");
    }
  }
  
  private void verifySubClasses(Token root)
  {
    try
    {
      for (Token t : root.getSubTokens())
      {
        if (!t.is("classDefinition") && !t.is("associationClassDefinition"))
        {
          continue;
        }
        
        if (!classHasPositioning(umpleParser.getRootToken(), t))
        {
          addPositioning(t);
        }
        else if (!classHasDefinition(umpleParser.getRootToken(), t))
        {
          textParser.replace(t, "");
          setUmpleCode(textParser.getText());
        }
                
        if (t.hasSubTokens())
        {
          verifySubClasses(t);
        }
      }
    }
    catch (Exception e)
    {
      handleException(e, "yo4");
    }    
  }
  
  private boolean classHasPositioning(Token root, Token t)
  {
    boolean hasPositioning = false;
    try
    {
      String targetClassName = t.getValue("name");
      
      if (addedPositions.contains(targetClassName))
      {
        return true;
      }
      
      for (Token classT : root.getSubTokens())
      {
        if (!classT.is("classDefinition") && !classT.is("associationClassDefinition"))
        {
          continue;
        }
        if (!classT.getValue("name").equals(targetClassName))
        {
          continue;
        }
        if (classT.getSubToken("elementPosition") == null)
        {
          continue;
        }
        hasPositioning = true;
        break;
      }
    }
    catch (Exception e)
    {
      handleException(e, "yo3");
    }
    return hasPositioning;
  }
  
  private boolean classHasDefinition(Token root, Token t)
  {
    try
    {
      String targetClassName = t.getValue("name");
      for (Token classT : root.getSubTokens())
      {
        if (!classT.is("classDefinition") && !classT.is("associationClassDefinition"))
        {
          continue;
        }
        
        if (classT.hasSubTokens())
        {
          if (classHasDefinition(classT, t))
          {
            return true;
          }
        }
        
        if (!classT.getValue("name").equals(targetClassName))
        {
          continue;
        }
        
        if (classT.getSubToken("elementPosition") != null)
        {
          continue;
        }
        
        return true;
      }
    }
    catch (Exception e)
    {
      handleException(e, "yo");
    }
    return false;
  }
  
  private void addPositioning(Token classT)
  {
    try
    {
      addedPositions.add(classT.getValue("name"));
      Json[] jsonClasses = json.getArray("umpleClasses");
      String targetClassName = classT.getValue("name");
      for (Json jsonClass : jsonClasses)
      {
        String jsonName = jsonClass.getValue("name");
        if (jsonName.equals(targetClassName))
        {
          Json jsonPosition = jsonClass.getAttribute("position");
          String x = jsonPosition.getValue("x");
          String y = jsonPosition.getValue("y");
          String width = jsonPosition.getValue("width");
          String height = jsonPosition.getValue("height");
        
          String newUmple = getUmpleCode();
          if (newUmple.length() > 0)
          {
            newUmple += "\n";
          }
          
          //String umpleClassType = "";
          //if (classT.is("associationClassDefinition"))
          //{
          //  umpleClassType = "associationClass";
          //}
          //else if (classT.is("classDefinition"))
          //{
          //  umpleClassType = "class";
          //}
          //String newPosition = StringFormatter.format("{0} {1}\n{\n  position {2} {3} {4} {5};\n}\n", umpleClassType, targetClassName, x, y, width, height);
          
          String newPosition = StringFormatter.format("{0} {1}\n{\n  position {2} {3} {4} {5};\n}\n", "class", targetClassName, x, y, width, height);
           
          newUmple += newPosition;
          setUmpleCode(newUmple);
        }
      }
    }
    catch (Exception e)
    {
      handleException(e, "yo2");
    }
  }
  
  private void handleException(Exception e, String message)
  {
    String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
    
    for (StackTraceElement trace : e.getStackTrace())
    {
      output += trace.toString() + "\n";
    }
    setUmpleCode(message + " " + output);
  }
}

class NewAction
{

  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for Debug
        //textParser.insert("//Unable to update umple code due to error at " + result.getPosition()  + "\n");
        //setUmpleCode(textParser.getText());
        //return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for debug
        //textParser.insert("//Unable to update umple code due to error at " + result.getPosition()  + "\n");
        //setUmpleCode(textParser.getText());
        //return;
      }

      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      Json json = jsonParser.analyze();
      
      if (!jsonResult.getWasSuccess())
      {
        //Uncomment for debug
        //setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }

      Json position = json.getAttribute("position");
      String className = json.getValue("name");
      String x = position.getValue("x");
      String y = position.getValue("y");
      String width = position.getValue("width");
      String height = position.getValue("height");
      String delimiter = "$?[End_of_model]$?";
      
      Token addAfterModel = null;
      for (Token t : umpleParser.getRootToken().getSubTokens())
      {
        // inlineComment has two tokens: "//" and "comment text"
        // we need to add the new class after the "comment text"
        if (t.isStatic("//") || t.isStatic("/*"))
        {
          continue;
        }
        
        if (t.is("inlineComment")|| t.is("multilineComment"))
        {
          if (!t.isValue(delimiter))
          {
            addAfterModel = t;
            continue;
          }
          break;
        }
        
        if (!t.is("classDefinition"))
        {
          if(!t.is("toplevelException"))
          {
              addAfterModel = t;
          }
          continue;
        }
          
        if (t.getSubToken("elementPosition") == null)
        {
          addAfterModel = t;
          continue;
        }
        break;
      }
      
      boolean didAddInModel = false;
      String newClassForModel = StringFormatter.format("class {0}\n{\n}\n\n", className);
      if (addAfterModel != null)
      {
        textParser.insertAfter(addAfterModel, newClassForModel);
        setUmpleCode(textParser.getText());
        didAddInModel = true;
      }
    
      String newUmple = getUmpleCode();
      if (newUmple.length() > 0)
      {
        newUmple += "\n";
      }
    
      if (!didAddInModel)
      {
        newUmple = newClassForModel + newUmple;
      }
      newUmple += StringFormatter.format("class {0}\n{\n  position {1} {2} {3} {4};\n}\n", className, x, y, width, height);
      setUmpleCode(newUmple);
    }
    
    catch (Exception e)
    {
      e.printStackTrace();
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
    
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }
}

class EditAction
{
  
  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      
      Json json = jsonParser.analyze();
      Json position = json.getAttribute("position");
      Json[] attributes = json.getArray("attributes");
      Json[] methods = json.getArray("methods");
      
      String newClassName = json.getValue("name");
      String oldClassName = json.getValue("oldname");
      String lookupName = oldClassName == null ? newClassName : oldClassName;
      
      boolean didEditName = false;
      boolean didEditAttributes = false;
      boolean didEditMethods = false;
      boolean didEditId = false;
      

      for (Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition") && !t.is("associationDefinition") && !t.is("associationClassDefinition"))
        {
          continue;
        }
        
        if (oldClassName != null)
        {
          for (Token subT : t.getSubTokens())
          {
            if (subT.is("inlineAssociation"))
            {
              Token associationEnd = subT.getSubToken("associationEnd");
              if (associationEnd == null) { continue; }
              Token type = associationEnd.getSubToken("type");
              if (type == null || !type.getValue().equals(oldClassName)) { continue; }
              textParser.replace(type,newClassName);
            }
            else if (subT.is("association"))
            {
              Token end1 = subT.getSubToken("associationEnd", 0);
              Token end2 = subT.getSubToken("associationEnd", 1);
              if (end1 != null) 
              {
                Token type1 = end1.getSubToken("type"); 
                if (type1 != null)
                {
                  if(type1.getValue().equals(oldClassName))
                  {
                    textParser.replace(type1,newClassName);
                  }
                } 
              }
              if (end2 != null) 
              {
                Token type2 = end2.getSubToken("type"); 
                if (type2 != null)
                {
                  if(type2.getValue().equals(oldClassName))
                  {
                    textParser.replace(type2,newClassName);
                  }
                } 
              }
            }
            else if (subT.is("extendsName"))
            {
              if (!subT.getValue().equals(oldClassName)) { continue; }
              textParser.replace(subT, newClassName);
            }
            else if (subT.is("associationPosition"))
            {
              Token type = subT.getSubToken("name");
              String temp = type.getValue();
              String[] names = temp.split("_");
              String res = "";
              for (int i=0; i<names.length; i++)
              {
                if (names[i].equals(oldClassName))
                    names[i] = newClassName;
                if (i != names.length-1)
                  res += names[i] + "_";
                else
                  res += names[i];
              }
              textParser.replace(type,res);
            }            
          }
        }
        
        if (!lookupName.equals(t.getValue("name")))
        {
          continue;
        }
        
        Token positionT = t.getSubToken("elementPosition");
        
        didEditName = true; 
        textParser.replace(t.getSubToken("name"),newClassName);
        if (positionT != null)
        {
          didEditId = true;
          textParser.replace(positionT.getSubToken("x"),position.getValue("x"));
          textParser.replace(positionT.getSubToken("y"),position.getValue("y"));
          textParser.replace(positionT.getSubToken("width"),position.getValue("width"));
          textParser.replace(positionT.getSubToken("height"),position.getValue("height"));
        }
        else
        {
          Token firstAssociationPositionT = null;
          for(Token subT : t.getSubTokens())
          {
            if (subT.is("associationPosition"))
            {
              firstAssociationPositionT = subT;
            }
          }
          if (firstAssociationPositionT != null)
          {
            didEditId = true;
            String newClassPosition = StringFormatter.format("  position {0} {1} {2} {3};\n",position.getValue("x"),position.getValue("y"),position.getValue("width"),position.getValue("height")); 
            textParser.insertAfter(firstAssociationPositionT, newClassPosition);
          } 
        }
                
        if (!didEditAttributes && attributes != null)
        {
          didEditAttributes = true;
          for (Json attr : attributes)
          {
            if (attr.getValue("deleteName") != null)
            {
              for(Token subT : t.getSubTokens())
              {
                if (subT.is("attribute") && attr.getValue("deleteName").equals(subT.getValue("name")))
                {
                  textParser.replace(subT,"");
                }
              }
            }
            else if (attr.getValue("newName") != null)
            {
              Token addAfterLastAttribute = null;
              Token addBefore = null;
              for (Token subT : t.getSubTokens())
              {
                boolean wasAdded = false;
                if (addAfterLastAttribute == null || subT.isStatic("{") || subT.is("attribute")) // } TODO: FIX PARSER COUPLES
                {
                  wasAdded = true;
                  addAfterLastAttribute = subT;
                  addBefore = null;
                }
                if (!wasAdded && addAfterLastAttribute != null && addBefore == null)
                {
                  addBefore = subT;
                }
                if(subT.is("concreteMethodDeclaration"))
                  break;
              }
              
              String type = "String".equals(attr.getValue("newType")) ? "" : StringFormatter.format("{0} ",attr.getValue("newType"));
              String attribute = "";
              
              if (addBefore.isStatic("}")) // { TODO: FIX PARSER COUPLES
              {
                attribute = StringFormatter.format("  {0}{1};\n",type,attr.getValue("newName"));
              }
              else
              {
                attribute = StringFormatter.format("{0}{1};\n",type,attr.getValue("newName"));
              }

              if(addAfterLastAttribute.is("concreteMethodDeclaration"))
                textParser.insertAfter(addBefore, attribute);
              else
                textParser.insertAfter(addAfterLastAttribute, attribute);
            }
            else if (attr.getValue("oldName") != null)
            {
              
              for(Token subT : t.getSubTokens())
              {
                if (subT.is("attribute") && attr.getValue("oldName").equals(subT.getValue("name")))
                {
                  Token type = subT.getSubToken("type");
                  Token name = subT.getSubToken("name");
                  boolean isDefaultType = "String".equals(attr.getValue("type"));

                  if (type == null && !isDefaultType)
                  {
                    textParser.replace(name,StringFormatter.format("{0} {1}",attr.getValue("type"),attr.getValue("name")));
                    continue;
                  }

                  if (type != null && !isDefaultType)
                  {
                    textParser.replace(type,attr.getValue("type"));
                  }
                  else if (type != null && isDefaultType)
                  {
                    textParser.replace(type,"");
                  }
                  textParser.replace(name,attr.getValue("name"));
                }
              }
            }
          }
        }
        if (!didEditMethods && methods != null)
        {
          didEditMethods = true;
          for (Json attr : methods)
          {

            if (attr.getValue("deleteName") != null)
            {
              for(Token subT : t.getSubTokens())
              {
                if (subT.is("concreteMethodDeclaration") && attr.getValue("deleteName").equals(subT.getSubToken("methodDeclarator").getValue("methodName")) && parametersMatch(attr,subT,"deleteParameters"))
                {
                  textParser.replace(subT,"");
                  break;
                }
              }
            }

            else if (attr.getValue("newName") != null)
            {
              Token addAfterLastMethod = null;
              Token addAfterLastAttribute = null;
              for (Token subT : t.getSubTokens())
              {
                if (addAfterLastAttribute == null || subT.isStatic("{") || subT.is("attribute"))
                {
                  addAfterLastAttribute = subT;
                }
                if(subT.is("concreteMethodDeclaration"))
                {
                  addAfterLastMethod = subT;
                }
              }
              String method = StringFormatter.format("{0} {1} {2}({3}){\n\n}\n",attr.getValue("newVisibility"),attr.getValue("newType"),attr.getValue("newName"),mergeParameters(attr,"newParameters",true));
              if(addAfterLastMethod != null)
                textParser.insertAfter(addAfterLastMethod, method);
              else
                textParser.insertAfter(addAfterLastAttribute, method);
            }

            else if (attr.getValue("oldName") != null)
            {
              
              for(Token subT : t.getSubTokens())
              {
                if (subT.is("concreteMethodDeclaration") && attr.getValue("oldName").equals(subT.getSubToken("methodDeclarator").getValue("methodName")) && parametersMatch(attr,subT,"oldParameters"))
                {
                  Token visibility = subT.getSubToken("modifier");
                  Token parameters = subT.getSubToken("methodDeclarator").getSubToken("parameterList");
                  Token type = subT.getSubToken("type");
                  Token name = subT.getSubToken("methodDeclarator").getSubToken("methodName");

                  
                  textParser.replace(parameters, "(" + mergeParameters(attr,"parameters",true) + ")"); //TODO properly sync method parameters instead of overwriting
                  textParser.replace(name, attr.getValue("name"));
                  textParser.replace(type, attr.getValue("type"));
                  textParser.replace(visibility, attr.getValue("visibility"));
                  break;
                }
              }
            }
          }
        }
      }
      setUmpleCode(textParser.getText());
      
      if (didEditName && !didEditId)
      {
        String x = position.getValue("x");
        String y = position.getValue("y");
        String width = position.getValue("width");
        String height = position.getValue("height");
        
        String newUmple = getUmpleCode();
        if (newUmple.length() > 0)
        {
          newUmple += "\n";
        }
        newUmple += StringFormatter.format("class {0}\n{\n  position {1} {2} {3} {4};\n}\n", newClassName, x, y, width, height);
        setUmpleCode(newUmple);
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
      
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }

  private String mergeParameters(Json token, String variable, boolean addArg)
  {
    StringBuffer allParameters = new StringBuffer();
    int counter = 0;
    for(Json params : token.getArray(variable))
    {
      if(counter > 0)
        allParameters.append(",");
      StringBuffer param = new StringBuffer();
      for(Json str : params.getComposites())
      {
        param.append(str.getValue());
      }
      if(!param.toString().trim().equals(""))
      {
        allParameters.append(param.toString());
        if(addArg)
          allParameters.append(" arg"+(counter++));
        else
          counter++;
      }
    }
    return allParameters.toString();
  }

  private boolean parametersMatch(Json attr, Token subT, String variable)
  {
    Token paramList = subT.getSubToken("methodDeclarator").getSubToken("parameterList");  
    StringBuffer paramTypes = new StringBuffer();
    int counter = 0;
    for(Token paramToken : paramList.getSubTokens())
    {
      if(paramToken.is("parameter"))
      {
        if(counter > 0)
          paramTypes.append(",");
        if(paramToken.getSubToken("type") !=null)
        {
          paramTypes.append(paramToken.getSubToken("type").getValue());
          counter++;
        }
      }
    }
    String[] Lparams = paramTypes.toString().split(",");
    String[] Rparams = mergeParameters(attr,variable,false).split(",");
    if(Lparams.length != Rparams.length)
      return false;
    for(int i = 0; i<Lparams.length;++i)
    {
      if(!Lparams[i].equals(Rparams[i]))
      {  
        return false;
      }
    }
    return true;
  } 

}


class DeleteAction
{

  public void go()
  { 
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }

      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      
      Json json = jsonParser.analyze();
      String className = json.getValue("name");
      
      for(Token t : umpleParser.getRootToken().getSubTokens()) 
      {
        if (!t.is("classDefinition") && !t.is("associationClassDefinition"))
        {
          continue;
        }
        
        if (className.equals(t.getValue("name")))
        {
          textParser.replace(t, "");
        }
      }
      setUmpleCode(textParser.getText());
    }
    catch (Exception e)
    {
      e.printStackTrace();
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
      
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }
}


class NewAssociationAction
{

  public void go()
  {
    boolean shouldContinue = true;
    
    if (shouldContinue)
    {
      shouldContinue = addAssociationPosition();  
    }
    
    if (shouldContinue)
    {
      shouldContinue = addAssociationDescription();  
    }
  }
  
  private boolean addAssociationPosition()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return false;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return false;
      }
      
      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        System.out.println("delta code:\n" + getDeltaCode() + "\n\numple code:\n" + getUmpleCode());
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return false;
      }
      
      Json json = jsonParser.analyze();
      Json position1 = json.getAttribute("offsetOnePosition");
      Json position2 = json.getAttribute("offsetTwoPosition");
      
      String classOneName = json.getValue("classOneId");
      String associationName = json.getValue("name");

      boolean didAdd = false;
      
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
        
        if (!classOneName.equals(t.getValue("name")))
        {
          continue;
        }
        
        Token lastAssociationPositionT = null;
        for(Token subT : t.getSubTokens())
        {
          if (subT.is("associationPosition"))
          {
            lastAssociationPositionT = subT;
          }
        }
        
        Token positionT = t.getSubToken("elementPosition");
        if (lastAssociationPositionT != null)
        {
          String newAssociationPosition = StringFormatter.format("  position.association {0} {1},{2} {3},{4};\n",associationName,position1.getValue("x"),position1.getValue("y"),position2.getValue("x"),position2.getValue("y"));
          textParser.insertAfter(lastAssociationPositionT, newAssociationPosition);
          didAdd = true;
        }
        else if (!didAdd && positionT != null)
        {
          String newAssociationPosition = StringFormatter.format("  position.association {0} {1},{2} {3},{4};\n",associationName,position1.getValue("x"),position1.getValue("y"),position2.getValue("x"),position2.getValue("y"));
          textParser.insertAfter(positionT, newAssociationPosition);
          didAdd = true;
        }
      }
     
      if (!didAdd)
      {
        String newUmple = getUmpleCode();
        if (newUmple.length() > 0)
        {
          newUmple += "\n";
        }
        newUmple += StringFormatter.format("class {0}\n{1}\n  position.association {2} {3},{4} {5},{6};\n{7}\n",classOneName,"{",associationName,position1.getValue("x"),position1.getValue("y"),position2.getValue("x"),position2.getValue("y"),"}");
        setUmpleCode(newUmple);
      }
      else
      {
        setUmpleCode(textParser.getText());
      }
      return true;
    }
    catch (Exception e)
    {
      return handleException(e);
    }
  }
  
  private boolean addAssociationDescription()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for debug
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return false;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        //Uncomment for debug
        //textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        //setUmpleCode(textParser.getText());
        return false;
      }
      
      JsonParser jsonParser = new JsonParser("json");
      jsonParser.parse("json", getDeltaCode());
      
      Json json = jsonParser.analyze();
      
      String classOneId = json.getValue("classOneId");
      String classTwoId = json.getValue("classTwoId");
      String firstRole = json.getValue("roleOne");
      String secondRole = json.getValue("roleTwo");
      Token addAfterLastAssociation = null;
      
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
        
        if (!classOneId.equals(t.getValue("name")))
        {
          continue;
        }
        int i = 0;
        for(Token subT : t.getSubTokens())
        {
          if (subT.is("extendsName"))
          {
            addAfterLastAssociation = t.getSubToken(i+1); // ";" is not included in the "extendsName" token
          }
          
          if (addAfterLastAssociation == null || subT.isStatic("{") || subT.is("inlineAssociation") || subT.is("attribute")) // TODO }
          {
            addAfterLastAssociation = subT;
          }
          ++i;
        }
        break;
      }
      
      if(firstRole == null) 
      {
        firstRole = "";
      }

      if(secondRole == null || secondRole.equals("")) 
      {
        secondRole = "";
      }
      else 
      {
        secondRole = " " + secondRole;
      }

      String newAssociation = StringFormatter.format(" {0} * -- * {1}{2};\n", firstRole, classTwoId, secondRole);
      textParser.insertAfter(addAfterLastAssociation, newAssociation);
      setUmpleCode(textParser.getText());
      return true;
    }
    catch (Exception e)
    {
      return handleException(e);
    }
  }
  
  private boolean handleException(Exception e)
  {
    String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
    
    for (StackTraceElement trace : e.getStackTrace())
    {
      output += trace.toString() + "\n";
    }
    setUmpleCode(output);
    return false;
  }
}


class EditAssociationAction
{

  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      
      Json json = jsonParser.analyze();
      
      Json position1 = json.getAttribute("offsetOnePosition");
      Json position2 = json.getAttribute("offsetTwoPosition");
      String class1 = json.getValue("classOneId");
      String x1 = position1.getValue("x");
      String y1 = position1.getValue("y");
      String x2 = position2.getValue("x");
      String y2 = position2.getValue("y");  
      String associationName = json.getValue("name");
      
      Token lastAssociationPositionT = null;  
      Token classPositionT = null;
      boolean didEdit = false;
      boolean isInline = false;
      
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition") && !t.is("associationClassDefinition"))
        {
          continue;
        }
        
        String currentClassName = t.getValue("name");
        Token currentClassPosition = t.getSubToken("elementPosition");
        
        if (!currentClassName.equals(class1))
        {
          continue;
        }
        
        if (currentClassPosition != null && currentClassName.equals(class1))
        {
          classPositionT = currentClassPosition;
        }
          
        for(Token subT : t.getSubTokens())
        {
          String currentName = "";
          String firstClassName = t.getValue("name");
          String secondClassName = "";
          String firstRole = "";
          String secondRole = "";
          
          if (subT.is("inlineAssociation"))
          {
            secondClassName = subT.getSubToken("associationEnd").getValue("type");
            firstRole = subT.getSubToken("inlineAssociationEnd").getValue("roleName");
            secondRole = subT.getSubToken("associationEnd").getValue("roleName");
            firstRole = firstRole == null? "" : ":" + firstRole; 
            secondRole = secondRole == null? "" : ":" + secondRole;
          
            String firstHalf = firstClassName + firstRole;
            String secondHalf = secondClassName + secondRole;
            
            if (firstHalf.compareTo(secondHalf) <= 0)
            {
              currentName = firstHalf + "__" + secondHalf;
            }
            else
            {
              currentName = secondHalf + "__" + firstHalf;
            }
            
            if (currentName.equals(associationName))
            {
              isInline = true;
            }
          }
          else if (subT.is("singleAssociationEnd"))
          {
            secondClassName = subT.getValue("type");
            secondRole = subT.getValue("roleName");
            secondRole = secondRole == null? "" : ":" + secondRole;
          
            if (firstClassName.compareTo(secondClassName) < 0)
            {
              currentName = firstClassName + firstRole + "__" + secondClassName + secondRole;
            }
            else
            {
              currentName = secondClassName + secondRole + "__" + firstClassName + firstRole;
            }
          
            if (currentName.equals(associationName))
            {
              isInline = true;
            }
          }
          
          if (!subT.is("associationPosition"))
          {
            continue;
          }
          
          lastAssociationPositionT = subT;
            
          if (!subT.getValue("name").equals(associationName))
          {
            continue;
          }
          
          Token coordinate1 = subT.getSubToken("coordinate",0);
          Token coordinate2 = subT.getSubToken("coordinate",1);
              
          textParser.replace(coordinate1.getSubToken("x"), x1);
          textParser.replace(coordinate1.getSubToken("y"), y1);
          textParser.replace(coordinate2.getSubToken("x"), x2);
          textParser.replace(coordinate2.getSubToken("y"), y2);
          
          didEdit = true;
          isInline = true;
          setUmpleCode(textParser.getText());
          break;
        }
      }   
      
      if (isInline && !didEdit && lastAssociationPositionT != null)
      {
        textParser.insertAfter(lastAssociationPositionT, StringFormatter.format("  position.association {0} {1},{2} {3},{4};\n",associationName,x1,y1,x2,y2));
        didEdit = true;
        setUmpleCode(textParser.getText());
      }
         
      else if (isInline && !didEdit && classPositionT != null)
      {
        textParser.insertAfter(classPositionT, StringFormatter.format("  position.association {0} {1},{2} {3},{4};\n",associationName,x1,y1,x2,y2));
        didEdit = true;
        setUmpleCode(textParser.getText());
      }
    
      else if (isInline && !didEdit)
      {
        String newUmple = getUmpleCode();
        if (newUmple.length() > 0)
        {
          newUmple += "\n";
        }
        newUmple += StringFormatter.format("class {0}\n{1}\n  position.association {2} {3},{4} {5},{6};\n{7}\n",class1,"{",associationName,x1,y1,x2,y2,"}");
        setUmpleCode(newUmple);
      }
      
    }
    catch (Exception e)
    {
      handleException(e);
    }
  }
  
  private boolean handleException(Exception e)
  {
    String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
    
    for (StackTraceElement trace : e.getStackTrace())
    {
      output += trace.toString() + "\n";
    }
    setUmpleCode(output);
    return false;
  }
}

class DeleteAssociationAction
{

  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);

      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      Json json = jsonParser.analyze();
      
      String associationName = json.getValue("name");
      String classOfAssociationDefinition = json.getValue("classOneId");
      
      boolean didDeletePosition = false;
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
  
        if (!t.getValue("name").equals(classOfAssociationDefinition))
        {
          continue;
        }
        
        for(Token positionT : t.getSubTokens())
        {
          if (!positionT.is("associationPosition"))
          {
            continue;
          }
          
          if (!positionT.getValue("name").equals(associationName))
          {
            continue;
          }
          
          textParser.replace(positionT, "");
          didDeletePosition = true;
          break;
        }
        
        if (didDeletePosition)
        {
          break;
        }
      }   
      
      boolean didDeleteDefinition = false;
      for (Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
        
        if (!t.getValue("name").equals(classOfAssociationDefinition))
        {
          continue;
        }
        
        for (Token subT : t.getSubTokens())
        {
          if (!subT.is("inlineAssociation"))
          {
            continue;
          }
          
          String currentName = "";
          String firstClassName = t.getValue("name");
          String secondClassName = subT.getSubToken("associationEnd").getValue("type");
          String firstRole = subT.getSubToken("inlineAssociationEnd").getValue("roleName");
          String secondRole = subT.getSubToken("associationEnd").getValue("roleName");
          firstRole = firstRole == null? "" : ":" + firstRole; 
          secondRole = secondRole == null? "" : ":" + secondRole;
          
          if (firstClassName.compareTo(secondClassName) < 0)
          {
            currentName = firstClassName + firstRole + "__" + secondClassName + secondRole;
          }
          else
          {
            currentName = secondClassName + secondRole + "__" + firstClassName + firstRole;
          }
          
          if (currentName.equals(associationName))
          {
            textParser.replace(subT, "");
            classOfAssociationDefinition = t.getValue("name");
            didDeleteDefinition = true;
            break;
          }
        }
        
        if (didDeleteDefinition)
        {
          break;
        }
      }
      
      setUmpleCode(textParser.getText());     
    }
    catch (Exception e)
    {
      e.printStackTrace();
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
      
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }
}

class DeleteGeneralizationAction
{

  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }

      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      Json json = jsonParser.analyze();
      String childId = json.getValue("childId");
      
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
        
        if (!childId.equals(t.getValue("name")))
        { 
          continue;
        }
        
        Token isAToken = null;
        Token semicolonToken = null;
        Token extendsNameToken = t.getSubToken("extendsName");
        
        if (extendsNameToken == null)
        {
          continue;
        }
        
        int i = 0;
        for(Token subT : t.getSubTokens())
        {
          if (subT.is("extendsName"))
          {
            extendsNameToken = subT;
            semicolonToken = t.getSubToken(i+1);
            isAToken = t.getSubToken(i-1);
            break;
          }
          i += 1;
        }
        textParser.replace(isAToken,"");
        textParser.replace(extendsNameToken,"");
        textParser.replace(semicolonToken,"");
      }
      setUmpleCode(textParser.getText());
    }
    catch (Exception e)
    {
      e.printStackTrace();
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
      
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }
}

class NewGeneralizationAction
{

  public void go()
  {
    try
    {
      TextParser textParser = new TextParser(getUmpleCode());
      UmpleFile umpleFile = new UmpleFile(new File(getFilename()));    
      UmpleModel umpleModel = new UmpleModel(umpleFile);
      cruise.umple.parser.analysis.RuleBasedParser parser = new cruise.umple.parser.analysis.RuleBasedParser(umpleModel);
      UmpleParser umpleParser = new UmpleInternalParser("UmpleInternalParser", umpleModel, parser);
      ParseResult result = parser.parse(umpleFile);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      result = umpleParser.analyze(false);
      
      if (!result.getWasSuccess())
      {
        textParser.insert("//Unable to update umple code due to error at " + result.getPosition() + "\n");
        setUmpleCode(textParser.getText());
        return;
      }
      
      JsonParser jsonParser = new JsonParser("json");
      ParseResult jsonResult = jsonParser.parse("json", getDeltaCode());
      
      if (!jsonResult.getWasSuccess())
      {
        setUmpleCode("//Failed at: " + jsonResult.getPosition() + "\n\n//" + getDeltaCode() + "\n\n" + getUmpleCode());
        return;
      }
      
      Json json = jsonParser.analyze();
      
      String childId = json.getValue("childId");
      String parentId = json.getValue("parentId");
      boolean alreadyHasExtends = false;
      
      for(Token t : umpleParser.getRootToken().getSubTokens())
      {
        if (!t.is("classDefinition"))
        {
          continue;
        }
        
        if (!childId.equals(t.getValue("name")))
        {
          continue;
        }
        
        if (t.getSubToken("extendsName") != null)
        {
          alreadyHasExtends = true;
        }
        
        for (Token subT : t.getSubTokens())
        {
          if (subT.isStatic("{") && !alreadyHasExtends)
          {
            String newGeneralization = StringFormatter.format("  isA {0};\n",parentId);
            textParser.insertAfter(subT, newGeneralization);
          }
        }
        break;
      }
      setUmpleCode(textParser.getText());
    }
    catch (Exception e)
    {
      String output = "FATAL ERROR PARSING UMPLE DIAGRAM\n\n";
    
      for (StackTraceElement trace : e.getStackTrace())
      {
        output += trace.toString() + "\n";
      }
      setUmpleCode(output);
    }
  }
}
