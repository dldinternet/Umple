namespace cruise.umple.compiler;

class UmpleInternalParser
{

//----------------------------------------------------------------------------  
//---------------------------------Start--------------------------------------
//----------------------------------------------------------------------------   

  private boolean isUmpleTrait(String elementName){
    return (model.getUmpleTrait(elementName) != null) ? true: false;
  }

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void analyzeTraitToken(Token t, int analysisStep)
  {
   if (analysisStep != 2)
    {
      shouldProcessAgain = shouldProcessAgain || (analysisStep == 1);
      return;
    }
    if (t.is("traitDefinition"))
    {
      analyzeTrait(t);
    }
    
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private UmpleTrait analyzeTrait (Token traitToken) {
   String traitName = traitToken.getValue("name").split(" ")[traitToken.getValue("name").split(" ").length-1];
    //Check to ensure the name is valid (starts with a letter, and only contains letters, numbers, or underscores
    if (Token.isValidIdentifier(traitName, "[A-Za-z]") != true) {
      setFailedPosition(traitToken.getPosition(), 2500, traitName);
    }
    else if ( traitName.matches("[a-z].*") ){ // Warn when class name does not start with a capital letter.    
      setFailedPosition(traitToken.getPosition(), 2501, traitName);
    }  
    UmpleTrait aTrait;
    aTrait = model.addUmpleTrait(traitToken.getValue("name"));
    
    Position thePosition = traitToken.getPosition();
    Position endPosition = traitToken.getEndPosition();

    // Set the original .ump file and line number
    aTrait.addPosition(thePosition);
    aTrait.addEndPosition(endPosition);
    
    // Add all the comments in the comment list to the Umple Trait.
    // But add them before any umplesource special comments
    int regularCommentCountEnd = 0;
    for (Comment c : aTrait.getComments()) {
      if(c.getText().startsWith("@umplesource")) break;
      regularCommentCountEnd++;
    }

    for (Comment c : lastComments)
    {
      aTrait.addCommentAt(c,regularCommentCountEnd);
      regularCommentCountEnd++;
    }

    // Add special position comment at the end if @outputumplesource had been 
    // detected earlier in a comment
    if(outputUmpleSource == true) {  
      aTrait.addComment(new Comment("@umplesource " + thePosition.getRelativePath((UmpleTrait)null,"Java")+" "+thePosition.getLineNumber()));
    }
    
  	// If the "abstract" keyword is parsed, make the Umple trait an abstract trait.
    if (traitToken.getValue("abstract") != null)
    {
      boolean wasSet = aTrait.setIsAbstract(true);
      
      // Ensure the value was set.
      if (wasSet == false)
      {
//TODO 3 I should change the code of error
        setFailedPosition(traitToken.getPosition(), 0, "Unable to make class abstract!");
      }
    }
    
	addExtendsTo(traitToken, aTrait, unlinkedExtends, unlinkedExtendsTokens);

    // If the "singleton" keyword is parsed, make the Umple class a singleton.
    if (traitToken.getValue("singleton") != null)
    {
      aTrait.setIsSingleton(true);
    }
    
    if("".equals(aTrait.getPackageName())){
      aTrait.setPackageName(currentPackageName);
  	}
  	
 	packageNameUsed = true;
    if (aTrait.getIsSingleton()) 
    {
      traitToken.setName(traitToken.getName());  
    }  
	
    if (traitToken.getValue("immutable") != null)
    {
      boolean wasSet = aTrait.setImmutable();
      if (!wasSet)
      {
        // Future-proofing: currently all paths cause wasSet to be true
//TODO 3 I should change the code of error    
        setFailedPosition(traitToken.getPosition(), 14, traitToken.getName());
      }
    }

   if (traitToken.getValue("traitParameters") != null ) {
    	proccessGeneralTemplateParameters(traitToken.getSubToken("traitParameters"), aTrait);
    }
	
    analyzeAllTokens(traitToken,aTrait);
         
    return aTrait; 
  }

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void analyzeAllTokens(Token rootToken, UmpleTrait aTrait){
    int analysisStep = 0;
    shouldProcessClassAgain = true;
    do
    {
      analysisStep += 1;
      shouldProcessClassAgain = false;
      for(Token token : rootToken.getSubTokens())
      {
        analyzeToken(token,aTrait,analysisStep);
        if (!getParseResult().getWasSuccess())
        {
          return;
        }
      }
    }
    while (shouldProcessClassAgain);
  }

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void analyzeToken(Token t, UmpleTrait aTrait, int analysisStep){

  	analyzeCoreToken(t,aTrait,analysisStep);
    analyzeTraitToken(t,aTrait,analysisStep);
    analyzeStateMachineToken(t,aTrait,analysisStep);
    analyzeDependentTokens(t,aTrait,analysisStep);
  }

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------  
  private void analyzeCoreToken(Token t, UmpleTrait aTrait, int analysisStep){
    
  } 

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void analyzeTraitToken(Token token, UmpleTrait aTrait, int analysisStep){
    if (analysisStep != 1)
    {
      return;
    }

    // Only need to clear comments if there actually was comments.
    boolean shouldConsumeComment = lastComments.size() > 0;
    
    // Determine what the current token is primarily, and based on that the analysis procedure is determined.
    if (token.isStatic("//") || token.isStatic("/*") || token.isStatic("*/"))
    {
      shouldConsumeComment = false;
    }
    else if (token.is("inlineComment"))
    {
      analyzeComment(token);
      shouldConsumeComment = addToLastAttributeOrAssociation(token);
    }
    else if (token.is("multilineComment"))
    {
      analyzeMultilineComment(token);
      shouldConsumeComment = false;
    }
    // TODO Under development
    
    else if (token.is("traitDefinition"))
    {
      UmpleTrait childTrait = analyzeTrait(token);
      boolean wasSet = childTrait.addExtendsTrait(aTrait);
      if (!wasSet)
      {
//TODO 4 I should change the code of error      
        setFailedPosition(token.getPosition(), 16, childTrait.getName(), aTrait.getName());
      }
    }
    else if (token.is("constantDeclaration"))
    {
      analyzeConstant(token,aTrait);
    }
    else if(token.is("constantDeclarationDeprecated"))
    {
//TODO 5 I should change the code of error    
      setFailedPosition(token.getPosition(), 901);
      analyzeConstant(token,aTrait);
    }
    else if (token.is("attribute"))
    {
      analyzeAttribute(token,aTrait);
    }
    else if (token.is("extraCode"))
    {
      analyzeExtraCode(token,aTrait);
    }
    else if (token.is("abstractMethodDeclaration"))
    {
      analyzeMethod(token,aTrait);
    }
    else if (token.is("concreteMethodDeclaration"))
    {
      analyzeMethod(token,aTrait);
    }
    else if (token.is("depend"))
    {
      Depend d = new Depend(token.getValue());
      aTrait.addDepend(d);
    }
    else if (token.is("inlineAssociation"))
    {
      analyzeinlineAssociation(token,aTrait);
    }
    else if (token.is("symmetricReflexiveAssociation"))
    {
      analyzeSymmetricReflexiveAssociation(token,aTrait);
    }    
    else if (token.is("exception"))
    {
      analyzeException(token,aTrait);
    }

    // This essentially "clears" the comments in the list so that new comments, when parsed, will be the ones appearing above
    // classes, methods, attributes, etc (whichever comes next) rather than old comments propogating everywhere.
    if (shouldConsumeComment)
    {
      lastComments.clear();
    }
  }
  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
   private void analyzeAttribute(Token attributeToken, UmpleTrait aTrait){
    boolean isAutounique = attributeToken.getValue("autounique") != null;
    boolean isUnique = attributeToken.getValue("unique") != null;
    boolean isLazy = attributeToken.getValue("lazy") != null;
    boolean isConstant = "const".equals(attributeToken.getValue("modifier"));
    boolean validName = Token.isValidIdentifier(attributeToken.getValue("name"));
    boolean properName = !Token.isValidIdentifier(attributeToken.getValue("name"), "[A-Z]");
    boolean looksLikeAssociation = attributeToken.getValue("name").contains("--") || attributeToken.getValue("name").contains("->");
    boolean isAGParameter = attributeToken.getValue("gpIdentifier") !=null;
    looksLikeAssociation = looksLikeAssociation || attributeToken.getValue("name").contains("<-") || attributeToken.getValue("name").contains("..");
    looksLikeAssociation = looksLikeAssociation || attributeToken.getValue("name").contains("*");
    
    String modifier = attributeToken.getValue("modifier");
    String type = attributeToken.getValue("type");
    String name = attributeToken.getValue("name");
    String value = attributeToken.getValue("value");
    String derivedValue = attributeToken.getValue("code");
    
    if(!validName)
    {
      if(looksLikeAssociation){      
        setFailedPosition(attributeToken.getPosition(), 132, name);
      } 
      else if(isConstant){
        setFailedPosition(attributeToken.getPosition(), 160, name);
      }
      else {
        setFailedPosition(attributeToken.getPosition(), 130, name);
      }
      
      return;
    }
    
    if (isAGParameter) {
    	if (aTrait.hasDefinedParameter(name,"")){
    		aTrait.setDefinedParameterType(name,"attribute");

    	} else {
        	setFailedPosition(attributeToken.getPosition(), 2556, name, aTrait.getName());
        }
    }    
    
    if(!properName && !isConstant){
      setFailedPosition(attributeToken.getPosition(), 131, name);
    }
    else if(properName && isConstant){
      setFailedPosition(attributeToken.getPosition(), 161, name);
    }
    
    //allow singleton with constant and predefined variables
    if (aTrait.getIsSingleton() && !isConstant && !isLazy && (value == null)) 
    {
      isLazy = true;
      setFailedPosition(attributeToken.getPosition(), 1, name);
    }
    
    // check to see if type has angle brackets <>
    if (type != null)
    {
      int lang_pos = type.lastIndexOf('<');
      int rang_pos = type.lastIndexOf('>');
      if (lang_pos > 0 && rang_pos > 0 && lang_pos < rang_pos)
      {
//TODO 6 I should change the code of error      
        setFailedPosition(attributeToken.getPosition(), 46, name, aTrait.getName(), type);
      }
    }
    
    if (isLazyRedundant(isLazy, value))
    {
//TODO 7 I should change the code of error
      setFailedPosition(attributeToken.getPosition(), 3, aTrait.getName(), name);
    }

    for(Attribute aAttribute : aTrait.getAttributes()){
      if (aAttribute.getName().equals(name)){
//TODO 8 I should change the code of error    
        setFailedPosition(attributeToken.getPosition(), 22, aTrait.getName(), name);
      }
    }
    CodeBlock languageSpecificCode = new CodeBlock();
    if (derivedValue != null)
    {
      value = "";
      List<String> codelangs = new ArrayList<String>();
      for(Token tkn: attributeToken.getSubTokens())
      {
      if(tkn.is("codeLang"))
      {
        codelangs.add(tkn.getValue());
      } else if(tkn.is("code")) {
        if(codelangs.isEmpty())
        {
          languageSpecificCode.setCode(tkn.getValue());
        } else {
          for(String lang: codelangs)
          {
            languageSpecificCode.setCode(lang, tkn.getValue());
          }
          codelangs.clear();
        }
      }
      }
    }

    if ("defaulted".equals(modifier) && value == null)
    {
      setFailedPosition(attributeToken.getPosition(), 6, attributeToken.getValue("name"));
      return;
    }

    if (isUnique)
    {
      UniqueIdentifier uniqueIdentifier = new UniqueIdentifier(name,type,modifier,value);
      aTrait.setUniqueIdentifier(uniqueIdentifier);
    }

    if (isAutounique)
    {
      type = "Integer";
    }

    if(type != null)
    { 
      Matcher m = Pattern.compile("([a-zA-Z_][0-9a-zA-Z_]*(<(.*)>)?)").matcher(type);
      if(!m.matches()) 
      {
        setFailedPosition(attributeToken.getPosition(), 140, type);
        return;
      }
    }
        
    if(type != null && value != null)
    {
      if(!compareTypeToValue(type,value))
      {
        setFailedPosition(attributeToken.getPosition(),141,type,value);  
      }
    }
    else if (type == null && value != null)
    {
      type = inferType(value, type);
    }
    else if(type == null)
    {
      type = "String";
    }


    if(attributeToken.getValue("modifier") != null)
    {
      if((attributeToken.getValue("modifier").contains("const")) && (attributeToken.getValue("value") == null))
      {
        value = defaultConstantValue(type, attributeToken);
      }
    }

    Attribute attribute = new Attribute(name,type,modifier,value,isAutounique,aTrait);
    attribute.setIsUnique(isUnique);
    attribute.setIsLazy(isLazy);
    boolean isList = attributeToken.getValue("list") != null;

    if (name == null)
    {
      String rawName = StringFormatter.toCamelCase(type); 
      name = isList ? model.getGlossary().getPlural(rawName) : rawName;
    }

    if (derivedValue != null)
    {
      attribute.setEndPosition(attributeToken.getEndPosition());
      attribute.setIsDerived(true);
      attribute.setCodeblock(languageSpecificCode);
    }

    // set position regardless of derivedValue    
    attribute.setPosition(attributeToken.getPosition());

    attribute.setIsList(isList);

    // Add comments above the attribute to the attribute.
    for (Comment c : lastComments)
    {
      attribute.addComment(c);
    }
    
    // set the last attribute made to be attribute, clear lastassoc
    lastattr = attribute;
    lastassoc = null;
  }  

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
   private void analyzeExtraCode(Token token, UmpleTrait aTrait){
    //This is a catch all and will be used less often as the grammar gets updated.
    
    if(extraCodeIsMalformedStateMachine(token)) setFailedPosition(token.getPosition(), 1006, "");
    //Append #line comment to indicate line and position of source
    if (token.getPosition() != null)
    {
      String extraCodeLineNumberComment = " line " + token.getPosition().getLineNumber() + " " + token.getPosition().getRelativePath(aTrait, "Java");
	  String rubyComment = "#" + extraCodeLineNumberComment;
	  String otherComment = "//" + extraCodeLineNumberComment;
 	  if(aTrait.hasExtraCode())
	  {
	    rubyComment = System.getProperty("line.separator") + rubyComment;
	    otherComment = System.getProperty("line.separator") + otherComment;
	  }
      CodeBlock cb = new CodeBlock();
      cb.setCode(otherComment);
      cb.setCode("Ruby", rubyComment);
      aTrait.appendExtraCode(true,cb);
      aTrait.appendExtraCode("  " + token.getValue());
    }
    else
    {
      aTrait.appendExtraCode(token.getValue());
    }
  }
  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
   private void analyzeinlineAssociation(Token inlineAssociationToken, UmpleTrait aTrait){
    
    Association association = analyzeAssociation(inlineAssociationToken,aTrait.getName());

    if (!getParseResult().getWasSuccess())
    {
      return;
    }

    AssociationEnd myEnd = association.getEnd(0);
    AssociationEnd yourEnd = association.getEnd(1);

    AssociationVariable myAs = new AssociationVariable(myEnd.getRoleName(),myEnd.getClassName(),myEnd.getModifier(),null,myEnd.getMultiplicity(),association.getIsLeftNavigable());
    AssociationVariable yourAs = new AssociationVariable(yourEnd.getRoleName(),yourEnd.getClassName(),yourEnd.getModifier(),null,yourEnd.getMultiplicity(),association.getIsRightNavigable());
    myAs.setRelatedAssociation(yourAs);
    
    if(!"".equals(myEnd.getPriority())) { myAs.setPriority(myEnd.getPriority()); }
    if(!"".equals(yourEnd.getPriority())) { yourAs.setPriority(yourEnd.getPriority()); }
    
    if (association.isImmutable())
    {
      boolean set = myAs.setImmutable();
      if (set)
      {
        yourAs.setImmutable();
      }
      else
      {
      	//TODO traits' errors
        setFailedPosition(inlineAssociationToken.getPosition(),17);
      }
    }

    // Add comments above the association to the association.
    for (Comment c : lastComments)
    {
      yourAs.addComment(c);
    }
    
    // set last association made to be yourAs. clear lastattr.
    lastassoc = yourAs;
    lastassocPosition = inlineAssociationToken.getPosition();
    lastattr = null;
    

    boolean added = aTrait.addAssociationVariable(yourAs);
    if (added)
    {
      unlinkedAssociationVariables.add(yourAs);
      aTrait.addAssociation(association);
    }
    else
    {
      if (aTrait.isImmutable()) {
      	//TODO traits' errors
      	setFailedPosition(inlineAssociationToken.getPosition(),17);
      } else {
      	//TODO traits' errors
      	setFailedPosition(inlineAssociationToken.getPosition(),13);
      }
    }
    
  }

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
   private void analyzeSymmetricReflexiveAssociation(Token symmetricReflexiveAssociationToken, UmpleTrait aTrait){
    /*
    String myName = symmetricReflexiveAssociationToken.getValue("roleName");
    String myType = aTrait.getName();
    String myModifier = "symmetricreflexive";
    String myBound = symmetricReflexiveAssociationToken.getValue("bound");
    String myLowerBound = symmetricReflexiveAssociationToken.getValue("lowerBound");
    String myUpperBound = symmetricReflexiveAssociationToken.getValue("upperBound");
    Multiplicity myMult = new Multiplicity();
    myMult.setBound(myBound);
    myMult.setRange(myLowerBound,myUpperBound);

    AssociationVariable myAs = new AssociationVariable(myName,myType,myModifier,null,myMult,true);
    AssociationVariable yourAs = new AssociationVariable(myName,myType,myModifier,null,myMult,true);

    myAs.setRelatedAssociation(yourAs);
    aTrait.addAssociationVariable(yourAs);
    
    AssociationEnd leftEnd = new AssociationEnd(null,myType,myModifier,myType,myMult);
    AssociationEnd rightEnd = new AssociationEnd(myName,myType,myModifier,myType,myMult);
    Association assoc = new Association(false, true, leftEnd, rightEnd);
    aTrait.addAssociation(assoc);
    */
  } 
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void analyzeException(Token exception, UmpleTrait aTrait){
    Token sub = exception.getSubToken(0);
    if(sub.is("misnamedAttribute"))
    {
      if(!Token.isValidIdentifier(sub.getValue("name")))
      {
        boolean looksLikeAssociation = sub.getValue("name").contains("--") || sub.getValue("name").contains("->");
        looksLikeAssociation = looksLikeAssociation || sub.getValue("name").contains("<-") || sub.getValue("name").contains("..");
        looksLikeAssociation = looksLikeAssociation || sub.getValue("name").contains("*");
        if(looksLikeAssociation)
        {
          setFailedPosition(sub.getPosition(), 132, sub.getValue("name"));
        }
        else 
        {
          setFailedPosition(sub.getPosition(), 130, sub.getValue("name"));
        }
        return;
      }
      if(Token.isValidIdentifier(sub.getValue("name"), "[A-Z]"))
      {
        setFailedPosition(sub.getPosition(), 131, sub.getValue("name"));
      }
      String type = sub.getValue("type");
      if(type!=null)
      {
        if(!Pattern.matches("([a-z]|[A-Z]|_)(\\d|\\w|<|>|,)*", type))
        {
          setFailedPosition(sub.getPosition(), 140, type);
        }
      }
    }
    else if(sub.is("malformedStatement1")||sub.is("malformedStatement2"))
    {
      String extraCode = "";
      for(Token token:sub.getSubTokens())
      {
        if(token.is("stuff"))
        {
          extraCode += token.getValue()+ " ";
        }
      }
      if(sub.getValue("innerstuff")!=null)
      {
        extraCode += "{"+sub.getValue("innerstuff")+"};";
      }
      else
      {
        extraCode += ";";
      }

      CodeBlock cb = new CodeBlock();
      String rubyComment = ("# line " + exception.getPosition().getLineNumber() + " " + exception.getPosition().getRelativePath(aTrait, "Java"));
      String otherComment = ("// line " + exception.getPosition().getLineNumber() + " " + exception.getPosition().getRelativePath(aTrait, "Java"));

      cb.setCode(otherComment);
      cb.setCode("Ruby", rubyComment);

      aTrait.appendExtraCode(true,cb);
      aTrait.appendExtraCode("  "+extraCode+"\n");

      setFailedPosition(sub.getPosition(), 1007, sub.getValue("name"));
    }
    else if(sub.is("malformedStatemachine1")||sub.is("malformedStatemachine2"))
    {
      String extraCode = "";
      for(Token token:sub.getSubTokens())
      {
        if(token.is("stuff"))
        {
          if(!"".equals(token.getValue())&&!token.getValue().contains(" ")&&!Token.isValidIdentifier(token.getValue()))
          {
            setFailedPosition(token.getPosition(), 150, token.getValue("name"));
          }
          extraCode += token.getValue()+ " ";
        }
      }
      extraCode += "\n  {\n    "+sub.getValue("innerstuff")+"\n  }";
      aTrait.appendExtraCode("// line " + exception.getPosition().getLineNumber() + " " + exception.getPosition().getRelativePath(aTrait, "Java"));
      aTrait.appendExtraCode("  "+extraCode+"\n");
      setFailedPosition(sub.getPosition(), 1006, sub.getValue("name"));
    }
    else if(sub.is("malformedMethod"))
    {
      String extraCode = "";
      for(Token token:sub.getSubTokens())
      {
        if(token.is("stuff"))
        {
          extraCode += token.getValue()+ " ";
        }
      }
      extraCode += "\n  {\n    "+sub.getValue("innerstuff")+"\n  }";
      aTrait.appendExtraCode("// line " + exception.getPosition().getLineNumber() + " " + exception.getPosition().getRelativePath(aTrait, "Java"));
      aTrait.appendExtraCode("  "+extraCode+"\n");
      setFailedPosition(sub.getPosition(), 1008, sub.getValue("name"));
    }
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
   private void analyzeDependentTokens(Token t, UmpleTrait uTrait, int analysisStep){
    if(analysisStep == 1 || shouldProcessClassAgain)
    {
      shouldProcessClassAgain = true;
      return;
    }

    // Methods after this point will occur on analysisStep > 1
    
    if (t.is("invariant"))
    {
      analyzeInvariant(t,uTrait);
    }
    else if (t.is("beforeCode") || t.is("afterCode"))
    {
    //TODO should applied for traits
      analyzeInjectionCode(t,uTrait);
    }
    else if (t.is("key") || t.is("defaultKey"))
    {
    //TODO should applied for traits
    //  analyzeKey(t,aClass);
    }
    //analyzeTraceToken(t,aClass);
    //analyzeLayoutToken(t,aClass,analysisStep);
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------

  private void applyTraits(){
  	if (getParseResult().getWasSuccess()) {
	    for (UmpleClass uClass : getModel().getUmpleClasses()) {
			if (uClass.hasExtendsTraits()) {
				copyAttributesFromTraitsToClass(uClass);
				copyMethodsFromTraitToClass(uClass);
				for (UmpleTrait uTrait : uClass.getExtendsTraits()) {
					recursiveApplyTraits(uClass,uTrait);
					
					
					if ( ! getParseResult().getWasSuccess() ) return;
				}
			}
		}
		checkAllRequiredMethods();
	}	
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void recursiveApplyTraits(UmpleClass inClass, UmpleTrait inTrait) {
	  if (inTrait.hasExtendsTraits()) {
		  applyTraitProperties(inClass, inTrait);
		  for (UmpleTrait uTrait : inTrait.getExtendsTraits()) {
			  recursiveApplyTraits(inClass,uTrait);
		  }
	  } else {
		  applyTraitProperties(inClass, inTrait);
	  }
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------    
private void copyMethodsFromTraitToClass(UmpleClass inClass){
    Map<UmpleTrait, List<Method>> traitMethods = new HashMap<UmpleTrait, List<Method>>();
	Map<UmpleTrait, List<Method>> tempTraitMethods = new HashMap<UmpleTrait, List<Method>>();
	for (UmpleTrait uTrait : inClass.getExtendsTraits()) {
		tempTraitMethods = gatherConcreteMethods(uTrait,inClass.getGeneralTPAppliedByName(uTrait.getName()));
		applyIncludeExcludeMethods(tempTraitMethods, uTrait, inClass);
		if ( ! getParseResult().getWasSuccess() ) return;
		checkMethodComeFromTraitsIsAvaiableInClass(tempTraitMethods,inClass);
		if (CheckMethodComeFromTraitsIsAvaialbleInOtherTraits(traitMethods,tempTraitMethods,inClass)) return;
		//traitMethods.putAll(tempTraitMethods);
		Map<UmpleTrait, List<Method>> tmp = new HashMap<UmpleTrait, List<Method>>(tempTraitMethods);
		tmp.keySet().removeAll(traitMethods.keySet());
		traitMethods.putAll(tmp);
	}
	for (UmpleTrait t1 : traitMethods.keySet()) {
		for (Method method : traitMethods.get(t1)) {
			method.getComment(2).setText(method.getComment(2).getText()+"'"+inClass.getName()+"' ");
			inClass.addMethod(method);   
		}
	}
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------     
   private Map<UmpleTrait, List<Method>> gatherConcreteMethods (UmpleTrait inTrait, GeneralTPApplied inGTPApplied) 
  {
	 Map<UmpleTrait, List<Method>> traitMethods = new HashMap<UmpleTrait, List<Method>>(); 
 	 Map<UmpleTrait, List<Method>> tempTraitMethods = new HashMap<UmpleTrait, List<Method>>();
 	 //----------------------------------------------------------------------------------------
 	 List<Method> methods = new ArrayList<Method>();	  
 	 for (Method method : inTrait.getMethods()) {
    	 if (! method.isIsAbstract()){ 
    	 	 Method newMethod = new Method(method);
    	 	 ApplyTypeParametersToMethod(newMethod,inGTPApplied);
 			 methods.add(newMethod);
	 	 }
	 }
     traitMethods.put(inTrait,methods);
     //----------------------------------------------------------------------------------------
     for (UmpleTrait uTrait : inTrait.getExtendsTraits()) {
     	tempTraitMethods = gatherConcreteMethods(uTrait,getNewGeneralTPAppliedWithP2P(inTrait,uTrait,inGTPApplied));
    	 //The first parameter works as in and out
    	 applyIncludeExcludeMethods(tempTraitMethods,uTrait,inTrait);  	 
    	 if ( ! getParseResult().getWasSuccess() ) return traitMethods;
    	 if (CheckMethodComeFromTraitsIsAvaialbleInOtherTraits(traitMethods,tempTraitMethods,inTrait)) return traitMethods;
    	 //traitMethods.putAll(tempTraitMethods);
    	 Map<UmpleTrait, List<Method>> tmp = new HashMap<UmpleTrait, List<Method>>(tempTraitMethods);
 		tmp.keySet().removeAll(traitMethods.keySet());
 		traitMethods.putAll(tmp);
	 }
     return traitMethods;
  }
  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------    
	private void applyIncludeExcludeMethods(Map<UmpleTrait, List<Method>> tempTraitMethods, UmpleTrait uTrait, UmpleClassifier inUmpleClassifier){
	   List<GeneralTPApplied> applied = new ArrayList<GeneralTPApplied>();
	   if (inUmpleClassifier instanceof UmpleClass){
		   applied = ((UmpleClass)inUmpleClassifier).getGeneralTPApplieds();
	   } else if (inUmpleClassifier instanceof UmpleTrait){
		   applied = ((UmpleTrait)inUmpleClassifier).getGeneralTPApplieds(); 
	   }
	   for(GeneralTPApplied gTPApplied : applied){
		 if (gTPApplied.getInheritanceName().equals(uTrait.getName()) ) {
			 Map<UmpleTrait, List<Method>> shouldTraitMethods = new HashMap<UmpleTrait, List<Method>>();
			 
			boolean add = false, found;
			for(MethodTemplateSignature mTSignature :  gTPApplied.getMethodTemplateSignatures()){
				found = false;
				for (UmpleTrait iETrait : tempTraitMethods.keySet()) {
					List<Method> shouldBeIncluded = new ArrayList<Method>();
					for (int i = 0; i < tempTraitMethods.get(iETrait).size(); i++) {
						if (compareTwoMethdos(tempTraitMethods.get(iETrait).get(i),mTSignature.getMethod())){
							if (mTSignature.getModifier().equals("-")){
								tempTraitMethods.get(iETrait).remove(i);
							} else if (mTSignature.getModifier().equals("+")){
								Method tempAiasNethod = new Method(tempTraitMethods.get(iETrait).get(i));
								if (!mTSignature.getAlias().equals("")){
									tempAiasNethod.setName(mTSignature.getAlias());
									//here I must check this new name is unique.
								}
								if (!mTSignature.getMethod().getModifier().equals("")){
									tempAiasNethod.setModifier(mTSignature.getMethod().getModifier());
									//here I must check this new name is unique.
								}
								shouldBeIncluded.add(tempAiasNethod);
								add = true;
							} else if (mTSignature.getModifier().equals("")){
								//here I must check this new name is unique.
								Method tempAiasNethod = new Method(tempTraitMethods.get(iETrait).get(i));
								tempTraitMethods.get(iETrait).remove(i);
								if (!mTSignature.getAlias().equals("")){
									tempAiasNethod.setName(mTSignature.getAlias());
									//here I must check this new name is unique.
								}						
								if (!mTSignature.getMethod().getModifier().equals("")){
									tempAiasNethod.setModifier(mTSignature.getMethod().getModifier());
								}
								tempTraitMethods.get(iETrait).add(tempAiasNethod);
							}
							found = true;
						}
					}
					if (add) {
						if (shouldTraitMethods.containsKey(iETrait)){
							shouldTraitMethods.get(iETrait).addAll(shouldBeIncluded);
						}else {
						shouldTraitMethods.put(iETrait, shouldBeIncluded);
						}
					}
				}
				if (!found){
					getParseResult().addErrorMessage(new ErrorMessage(2559,inUmpleClassifier.getPosition(0),mTSignature.getMethod().getName(),uTrait.getName()));	
			 		return; 
				}
			}
				if (add){
				tempTraitMethods.clear();
				tempTraitMethods.putAll(shouldTraitMethods);
				}
		 }
	 }
  } 

 //---------------------------------end----------------------------------------
 //----------------------------------------------------------------------------   
 //---------------------------------Start--------------------------------------    

  private void ApplyTypeParametersToTypeParameters(GeneralTPApplied newGTPA, GeneralTPApplied currentGTPA) {
  	 if (currentGTPA == null) return;
	 for (String strType : currentGTPA.getParameterMapping().keySet()){
			for(String key : newGTPA.getParameterMapping().keySet()){
				if (newGTPA.getParameterMapping().get(key).equals(strType)){
					newGTPA.getParameterMapping().put(key, currentGTPA.getParameterMapping().get(strType));
				}
			}
		}
  } 
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start-------------------------------------- 
	private void ApplyTypeParametersToAttribute(Attribute newAttribute,	GeneralTPApplied inGTPApplied) {
	    if (inGTPApplied == null) return;
		for (String strType : inGTPApplied.getParameterMapping().keySet()) {
			String newName = inGTPApplied.getParameterMapping().get(strType);
			if (newAttribute.getType().equals(strType)){
				newAttribute.setType(newName);
			}
		}	
	}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------  	
  private void checkTypeParameterAvailability(GeneralTPApplied inGeneralTPApplied) {
	UmpleTrait localTrait = getModel().getUmpleTrait(inGeneralTPApplied.getInheritanceName());
	   /*
	for (GeneralTemplateParameter gtp : inTrait.getGeneralTemplateParameters()) {
		if (!inParameterMapping.containsKey(gtp.getName())){
			//error: this is when we want to have full coverage for type parameters 
			return;
		}
	}
	*/
	   
	if (inGeneralTPApplied == null ) return;
	for (String	typeName : inGeneralTPApplied.getParameterMapping().keySet()) {
		if (!localTrait.hasGeneralTemplateParameter(typeName)){
			getParseResult().addErrorMessage(new ErrorMessage(2562,localTrait.getPosition(0),typeName)); 
			return;
		}
	}	
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------    
  private void ApplyTypeParametersToMethod(Method newMethod, GeneralTPApplied inGeneralTPApplied) {
  	if (inGeneralTPApplied == null) return;
	for (String strType : inGeneralTPApplied.getParameterMapping().keySet()) {
		String newName = inGeneralTPApplied.getParameterMapping().get(strType);
		if (newMethod.getType().equals(strType)){
			newMethod.setType(newName);
		}
		for (int i = 0; i < newMethod.numberOfMethodParameters(); i++) {
            if(newMethod.getMethodParameter(i).getType().equals(strType)){
            	newMethod.getMethodParameter(i).setType(newName);
            }
	    }
	}
  }
  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------  
  private void applyTraitProperties(UmpleClass inClass, UmpleTrait inTrait) {
		//set the singleton pattern
		if (! inClass.getIsSingleton()) inClass.setIsSingleton(inTrait.getIsSingleton());
		
		//set abstract keyword
		//if (! inClass.getIsAbstract())	inClass.setIsAbstract(inTrait.getIsAbstract());
		
		//set the comments
		for(Comment aComment : inTrait.getComments()) {
			inClass.addComment(aComment);
		}		
		
		//set the dependens
		for(Depend aDepend : inTrait.getDepends()) {
			inClass.addDepend(aDepend);
		}		
							
		// copy Precondition
		for(Precondition aPrecondition : inTrait.getPreconditions()) {
			inClass.addPrecondition(aPrecondition);
		}	
		
		// copy Postcondition
		for(Postcondition aPostcondition : inTrait.getPostconditions()) {
			inClass.addPostcondition(aPostcondition);
		}						

		//copy attributes
		/*
		for(Attribute aAttribute : inTrait.getAttributes()) {
			//check for attributes which have already existed.
			Integer index = inTrait.getGeneralTemplateParameterIndexByName(aAttribute.getName(),"attribute");
			if (index>=0){
				if (inClass.hasGeneralTPApplieds()) {
					GeneralTPApplied gtp = inClass.getGeneralTPAppliedByName(inTrait.getName());
					if (gtp != null){
						aAttribute.setName(	gtp.getParameter(index));
						inClass.addAttribute(aAttribute);
					}
							
				}
			} else {
				inClass.addAttribute(aAttribute);
			}
		}
		*/
		
		// copy Constraints
		for(Constraint aConstraint : inTrait.getConstraints()) {
			for(ConstraintVariable cVariable : aConstraint.getExpressions() ) {			
				if (cVariable.getType().equals("NAME") && inClass.getAttribute(cVariable.getValue()) == null && inTrait.getAttribute(cVariable.getValue()) == null) {
					getParseResult().addErrorMessage(new ErrorMessage(2554,inTrait.getPosition(0),cVariable.getValue(),inTrait.getName(),inClass.getName()));	
					return;
				}
			}
			inClass.addConstraint(aConstraint);
		}	
		
		// copy StateMachines
		for (StateMachine st : inTrait.getStateMachines()) {
			StateMachine stNew = new StateMachine(st.getName());
			stNew.setPooled(st.getPooled());
			stNew.setQueued(st.getQueued());
			stNew.setUmpleClass(inClass);
			for (State element : st.getStates()) {
				stNew.addState(element);
			}
			inClass.addStateMachine(stNew);
		}
		
       // copy injection codes
       for (CodeInjection cj : inTrait.getCodeInjections()) {
               cj.setUmpleClassifier(inClass);
               inClass.addCodeInjection(cj);
       }
       // copy Extra code
       inClass.appendExtraCode(inTrait.getExtraCode());
       
       // copy associations
       for (AssociationVariable aVariable : inTrait.getAssociationVariables()) {
    	   aVariable.setUmpleClass(inClass);
    	   UmpleClass relatedAss =  model.getUmpleClass(aVariable.getType()); 	   
    	   aVariable.getRelatedAssociation().setUmpleClass(relatedAss);
    	   aVariable.getRelatedAssociation().setType(inClass.getName());
	       String rawName = StringFormatter.toCamelCase(inTrait.getName());
	       String name = aVariable.getRelatedAssociation().getMultiplicity().isMany() ? model.getGlossary().getPlural(rawName) : rawName;
	       if (name.equals(aVariable.getRelatedAssociation().getName())){
	    	   rawName = StringFormatter.toCamelCase(inClass.getName());
	    	   name = aVariable.getRelatedAssociation().getMultiplicity().isMany() ? model.getGlossary().getPlural(rawName) : rawName;
	    	   aVariable.getRelatedAssociation().setName(name);
	       }
	       inClass.addAssociationVariable(aVariable);    
       }	  
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------  
	private void postTokenTraitAnalysis() {
		addUnlinkedExtendTraits();
		if ( getParseResult().getWasSuccess() ) {
			checkTraitsNamesWithClasses();
			checkTraitsNameWithInterfaces();
			checkCyclicTraitInheritance();
			checkTypeParametersAvailability();
		}
	}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void addUnlinkedExtendTraits()
  {  
    for (UmpleClassifier c : unlinkedExtends.keySet())
    {
      UmpleTrait child = null; // unlinkedExtends guaranteed to contain only UmpleTraits
      if (c instanceof UmpleTrait){
        child = (UmpleTrait) c;
      }  
    
      List<String> extendsNames = unlinkedExtends.get(child);    
      List<Token>  extendsToken = unlinkedExtendsTokens.get(child);

      if (extendsNames == null)
      {
        continue;
      }

      for (int i=0; i < extendsNames.size();i++){
        String extendName= extendsNames.get(i);
        Position pos;
		try
		{
			pos = extendsToken.get(i).getPosition();
		}
		catch(Exception e)
		{
			pos = new Position("",0,0,0);
		}
        if (isUmpleTrait(extendName) ) {
			
			//checking cyclically
			if (child.getName().equals(extendName)) {
				setFailedPosition(pos, 2551, child.getName());
			    return;
			}
			
			UmpleTrait parent = model.getUmpleTrait(extendName);
		     
		    boolean wasSet = child.addExtendsTrait(parent);
		    if (!wasSet) {
				// TODO 1: the error code should be chnaged.            
			    setFailedPosition(pos, 16, child.getName(), parent.getName());
			    return;
		    }
		    /*
		    try
		    {
		    	child.setExtendsToken(extendsToken.get(i));
		    }
		    catch(Exception e){}   	  
		    */     

		} else {
			setFailedPosition(pos, 2502, extendName);
			return;
		}
      }
    }
  }  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	 
  private void checkTypeParametersAvailability() {
	for (UmpleClass uClass : getModel().getUmpleClasses()) {
		for (GeneralTPApplied gTPApplied : uClass.getGeneralTPApplieds()) {
			checkTypeParameterAvailability(gTPApplied);
		}
	}
	for (UmpleTrait uTrait : getModel().getUmpleTraits()) {
		for (GeneralTPApplied gTPApplied : uTrait.getGeneralTPApplieds()) {
			checkTypeParameterAvailability(gTPApplied);
		}
	}
	
 }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	
	//Check traits to have unique names;
	private void checkTraitsNamesWithClasses() {
		for (UmpleTrait uTrait : getModel().getUmpleTraits()) {
			for(UmpleClass uClass : getModel().getUmpleClasses()) {
				if (uTrait.getName().equals(uClass.getName())) {
          			getParseResult().addErrorMessage(new ErrorMessage(2550,uTrait.getPosition(0),uTrait.getName()));
          			return;
				}
			}
		}
	}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	
  private void checkTraitsNameWithInterfaces() {
	  for (UmpleTrait uTrait : getModel().getUmpleTraits()) {
		  for (UmpleInterface uInterface : getModel().getUmpleInterfaces()) {
			  if (uTrait.getName().equals(uInterface.getName())) {
        			getParseResult().addErrorMessage(new ErrorMessage(2551,uTrait.getPosition(0),uTrait.getName()));
        			return;
				}
		  }
	  }
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
	private void checkCyclicTraitInheritance() {
		 for (UmpleTrait uTrait : getModel().getUmpleTraits()) {
			if (uTrait.hasExtendsTraits()) {
				checkCyclicTraitInheritance(uTrait,uTrait);
			}
		}
	 }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------	  
	 private void checkCyclicTraitInheritance(UmpleTrait base, UmpleTrait root) {
		 if (base.getExtendsTraits().contains(root)) {
			 getParseResult().addErrorMessage(new ErrorMessage(2553,base.getPosition(0),base.getName(), root.getName()));
			 return;
		 } else {
			 for (UmpleTrait uTrait :base.getExtendsTraits()) {
				 checkCyclicTraitInheritance(uTrait,root);
				 return;
			 }
		 }
	 }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void checkAllRequiredMethods() {
	  if ( getParseResult().getWasSuccess() ) {
		  for(UmpleClass uClass : getModel().getUmpleClasses()) {
			  for(UmpleTrait uTrait : uClass.getExtendsTraits())  {
				recursiveCheckRequiredMethods(uClass,uTrait,uClass.getGeneralTPAppliedByName(uTrait.getName()));
			  }
		  }
	  }
  }  
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void recursiveCheckRequiredMethods(UmpleClass inClass, UmpleTrait inTrait, GeneralTPApplied inGeneralTPApplied) {
	  if ( !getParseResult().getWasSuccess() ) return;  
	  if (inGeneralTPApplied == null) return;
	  for (UmpleTrait uTrait : inTrait.getExtendsTraits()) {
		  GeneralTPApplied newGeneralTPApplied =null;
		  if (inTrait.getGeneralTPAppliedByName(uTrait.getName())!=null)  newGeneralTPApplied = new GeneralTPApplied(inTrait.getGeneralTPAppliedByName(uTrait.getName()));
		  recursiveCheckRequiredMethods(inClass,uTrait,newGeneralTPApplied);
      }
	  for (Method uMethod : inTrait.getMethods() ) {
		  if (uMethod.isIsAbstract()) {
			  Method newMethod = new Method(uMethod);
			  ApplyTypeParametersToMethod(newMethod,inGeneralTPApplied);
			  if(!inClass.hasImplementedMethodIncludingWithinParentClasses(newMethod)){
				  getParseResult().addErrorMessage(new ErrorMessage(2555,newMethod.getPosition(),newMethod.getName(),inTrait.getName(),inClass.getName()));
				  return;
			  }
		  }
	  }
  } 
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start-------------------------------------- 
//****************************************************************************************
//This section is related to codes which is going to support general templates for traits
//****************************************************************************************
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
  private void proccessGeneralTemplateParameters(Token mainToken, UmpleTrait aTrait) {
	  String name = "";
	   for (Token subToken : mainToken.getSubTokens()) {
		  if (subToken.is("parameter")) {
			  name = subToken.getValue();
			  GeneralTemplateParameter gtParameter = new GeneralTemplateParameter(name,"");
			  if (aTrait.hasGeneralTemplateParameter(name)){
				  getParseResult().addErrorMessage(new ErrorMessage(2561,subToken.getPosition(),name,aTrait.getName() ));
				  return;
			  }
			  aTrait.addGeneralTemplateParameter(gtParameter);
		  }
	  }
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private void processGTemplateParameterAssignment(Token mainToken, UmpleClassifier aClassifier, String extendName) {
	GeneralTPApplied aGeneralTPApplied = new GeneralTPApplied(extendName);
    String parameterName;
	for(Token subToken : mainToken.getSubTokens()) {
		if (subToken.is("iEFunction") || subToken.is("functionAliasName")) {
			MethodTemplateSignature mtSignature =obtainMethodTemplateSignature(subToken);
				if (! aGeneralTPApplied.hasMethodTemplateSignature(mtSignature)){	
					aGeneralTPApplied.addMethodTemplateSignature(mtSignature);
				} else {
					getParseResult().addErrorMessage(new ErrorMessage(2558,subToken.getPosition(),aGeneralTPApplied.getInheritanceName(),mtSignature.getMethod().getName() ));
				    return;
			}
		} else if (subToken.is("traitAppliedParameters")){
				parameterName = subToken.getValue("pName");
				if (aGeneralTPApplied.getParameterMapping().containsKey(parameterName)){
					getParseResult().addErrorMessage(new ErrorMessage(2563,subToken.getPosition(),parameterName));
					return;
				}
				aGeneralTPApplied.getParameterMapping().put(parameterName, subToken.getValue("rName"));				
		}
	}
	if (aClassifier instanceof UmpleClass) {
		((UmpleClass)aClassifier).addGeneralTPApplied(aGeneralTPApplied);
	} else if (aClassifier instanceof UmpleTrait) {
		((UmpleTrait)aClassifier).addGeneralTPApplied(aGeneralTPApplied);
	}	
}

//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start-------------------------------------- 
  private MethodTemplateSignature obtainMethodTemplateSignature(Token inToken) {
	  String iEFunctionModifier="",methodAliasName ="";
	  String methodName = inToken.getValue("methodName");
	  String iEVisibility = "";
      if (inToken.getValue("iEFunctionModifier") != null) iEFunctionModifier = inToken.getValue("iEFunctionModifier");
	  if (inToken.getValue("methodAliasName") != null) methodAliasName = inToken.getValue("methodAliasName");
	  if (inToken.getValue("iEVisibility") != null)  iEVisibility = inToken.getValue("iEVisibility");
	  Method method = new Method(iEVisibility, methodName, "", false); 
	  if (inToken.getSubToken("iEParameterList") != null){
			for (Token subToken : inToken.getSubToken("iEParameterList")
					.getSubTokens()) {
				if (subToken.is("parameter")) {
					method.addMethodParameter(new MethodParameter("", subToken
							.getValue(), "", "", false));
				}
			}
	   }
	   
	  MethodTemplateSignature mtSignature = new MethodTemplateSignature(iEFunctionModifier,methodAliasName, method); 
	return mtSignature;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private void copyAttributesFromTraitsToClass(UmpleClass inClass){
	Map<UmpleTrait, List<Attribute>> traitAttributes = new HashMap<UmpleTrait, List<Attribute>>();
	Map<UmpleTrait, List<Attribute>> tempTraitAttributes = new HashMap<UmpleTrait, List<Attribute>>();
	for (UmpleTrait uTrait : inClass.getExtendsTraits()) {
		tempTraitAttributes = gatherAttributes(uTrait,inClass.getGeneralTPAppliedByName(uTrait.getName()));
		if ( ! getParseResult().getWasSuccess() ) return;
		if (checkAttComeFromTraitsIsAvaiableInClass(tempTraitAttributes,inClass) ) return;
		if (CheckAttComeFromTraitsIsAvaialbleInOtherTraits(traitAttributes,tempTraitAttributes)) return;
		traitAttributes.putAll(tempTraitAttributes);
	}
	for (UmpleTrait t1 : traitAttributes.keySet()) {
		for (Attribute attribute : traitAttributes.get(t1)) {
			//I need some comment for users in generated code;
			//attribute.getComment(2).setText(attribute.getComment(2).getText()+"'"+inClass.getName()+"' ");
			inClass.addAttribute(attribute);  
		}
	}
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private Map<UmpleTrait, List<Attribute>> gatherAttributes(UmpleTrait inTrait, GeneralTPApplied inGTPApplied) {
	 Map<UmpleTrait, List<Attribute>> traitAttributes = new HashMap<UmpleTrait, List<Attribute>>(); 
	 Map<UmpleTrait, List<Attribute>> tempTraitAttributes = new HashMap<UmpleTrait, List<Attribute>>();
	 //----------------------------------------------------------------------------------------
	 List<Attribute> attributes = new ArrayList<Attribute>();	  
	 for (Attribute attribute : inTrait.getAttributes()) {
		 Attribute newAttribute = new Attribute(attribute);
	 	 ApplyTypeParametersToAttribute(newAttribute,inGTPApplied);
		 attributes.add(newAttribute);
	 }
    traitAttributes.put(inTrait,attributes);
    //----------------------------------------------------------------------------------------
    for (UmpleTrait uTrait : inTrait.getExtendsTraits()) {
    	tempTraitAttributes = gatherAttributes(uTrait,getNewGeneralTPAppliedWithP2P(inTrait,uTrait,inGTPApplied));   	 
   	 	if ( ! getParseResult().getWasSuccess() ) return traitAttributes;
   	 	if (CheckAttComeFromTraitsIsAvaialbleInOtherTraits(traitAttributes, tempTraitAttributes)) return traitAttributes;
   	 	traitAttributes.putAll(tempTraitAttributes);
	}
    return traitAttributes;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private boolean isMethdoAvailable(Map<UmpleTrait, List<Method>> inTraitMethods, Method inMethod) {
	for (UmpleTrait uTrait : inTraitMethods.keySet()) {
		for(Method method : inTraitMethods.get(uTrait)){
			if(compareTwoMethdos(method, inMethod)){		
				return true;
			}
		}
	}
	return false;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
//****************************************************************************************
//end of a special section
//****************************************************************************************
  private boolean compareTwoMethdos(Method method1, Method method2) {
	  if (method1.getName().equals(method2.getName())){
		 // if(method1.getType().equals(method2.getType())){
			  Integer numberOfParams = method1.getMethodParameters().size();
			  if ( numberOfParams== method2.getMethodParameters().size()) {
		          boolean allSame = true;
		          for (int i = 0; i < numberOfParams; i++)
		          {
		            if(!method1.getMethodParameter(i).getType().equals(method2.getMethodParameter(i).getType()))
		            {
		              allSame = false;
		              break;
		            }
		          }
		          if(allSame)
		          {
		            return true;
		          }
		     }
		 // }  
      }
	  return false;
  }
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private boolean checkAttComeFromTraitsIsAvaiableInClass(Map<UmpleTrait, List<Attribute>> inTraitAttributes, UmpleClass inClass) {
	for (UmpleTrait uTrait : inTraitAttributes.keySet()){
		for (Attribute attribute : inTraitAttributes.get(uTrait)) {
			if (inClass.getAttribute(attribute.getName())!=null) {
				getParseResult().addErrorMessage(new ErrorMessage(2552,inClass.getPosition(0),attribute.getName(), uTrait.getName(),inClass.getName() ));	
				return true;
			}
		}
	}
	return false;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private boolean CheckAttComeFromTraitsIsAvaialbleInOtherTraits(	Map<UmpleTrait, List<Attribute>> inTraitAttributes,Map<UmpleTrait, List<Attribute>> inTempTraitAttributes) {
	for (UmpleTrait uTrait : inTempTraitAttributes.keySet()){
		for (Attribute attribute : inTempTraitAttributes.get(uTrait)) {
			for (UmpleTrait internalTrait : inTraitAttributes.keySet()) {
				for (int i = 0; i < inTraitAttributes.get(internalTrait).size(); i++) {
					Attribute internalAttribute = inTraitAttributes.get(internalTrait).get(i);
					if (attribute.getName().equals(internalAttribute.getName())){
						if (uTrait.equals(internalTrait) && attribute.getType().equals(internalAttribute.getType())){
							//inTraitAttributes.get(internalTrait).remove(internalAttribute);
						} else {
							if (uTrait.equals(internalTrait)){
								getParseResult().addErrorMessage(new ErrorMessage(2564,uTrait.getPosition(0),attribute.getName(), uTrait.getName(),attribute.getType() ,internalAttribute.getType()));	
							} else{
								getParseResult().addErrorMessage(new ErrorMessage(2552,uTrait.getPosition(0),attribute.getName(), uTrait.getName(),internalTrait.getName() ));	
								
							}
							return true;
						}
					}
				}
			}
		}
	}	
	return false;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private GeneralTPApplied getNewGeneralTPAppliedWithP2P(UmpleTrait inTrait, UmpleTrait uTrait,GeneralTPApplied inGTPApplied) {
	 GeneralTPApplied newGeneralTPApplied = null;
	 if (inTrait.getGeneralTPAppliedByName(uTrait.getName()) !=null) {
	 	newGeneralTPApplied = new GeneralTPApplied(inTrait.getGeneralTPAppliedByName(uTrait.getName()));
     	ApplyTypeParametersToTypeParameters(newGeneralTPApplied,inGTPApplied);
     }
	return newGeneralTPApplied;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private void checkMethodComeFromTraitsIsAvaiableInClass(Map<UmpleTrait, List<Method>> inTempTraitMethods, UmpleClass inClass) {
	for (UmpleTrait uTrait : inTempTraitMethods.keySet()){
		for (int i = 0; i < inTempTraitMethods.get(uTrait).size(); i++) {
			if (inClass.hasMethod(inTempTraitMethods.get(uTrait).get(i))){
				inTempTraitMethods.get(uTrait).remove(i);
			}
		}
	}
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
private boolean CheckMethodComeFromTraitsIsAvaialbleInOtherTraits(Map<UmpleTrait, List<Method>> inTraitMethods,Map<UmpleTrait, List<Method>> inTempTraitMethods, UmpleClassifier inClassifier) {
	for (UmpleTrait uTrait : inTraitMethods.keySet()){
		for (Method method : inTraitMethods.get(uTrait)) {
			for (UmpleTrait internalTrait : inTempTraitMethods.keySet()) {
				for (int i = 0; i < inTempTraitMethods.get(internalTrait).size(); i++) {
					Method internalMethod = inTempTraitMethods.get(internalTrait).get(i);
					if (compareTwoMethdos(method, internalMethod)){
						if (uTrait.equals(internalTrait)){
							inTempTraitMethods.get(internalTrait).remove(i);
						} else if (inClassifier instanceof UmpleTrait){
							if (uTrait.equals((UmpleTrait)inClassifier)){
								inTempTraitMethods.get(internalTrait).remove(i);
							}
						} else {
							String type = "trait";	
							if (inClassifier instanceof UmpleClass) type = "class";
		
							getParseResult().addErrorMessage(new ErrorMessage(2557,inClassifier.getPosition(0),type, inClassifier.getName(),method.getName(),uTrait.getName(),internalTrait.getName()));	
							return true;
						}
					}
				}
			}
		}
	}	
	return false;
}
//---------------------------------end----------------------------------------
//----------------------------------------------------------------------------   
//---------------------------------Start--------------------------------------
}

use UmpleInternalParser_FIXML.ump;
