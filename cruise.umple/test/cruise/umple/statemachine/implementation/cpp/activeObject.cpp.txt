/* EXPERIMENTAL CODE - NON COMPILEABLE VERSION OF C++ */
/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE @UMPLE_VERSION@ modeling language!*/

#include "Lamp.h"

	
  //------------------------
  // CONSTRUCTOR
  //------------------------
  
 Lamp::Lamp(const String & aLog)
  {
    log = aLog;
    if (activeStateMachineActiveTopLevelState == Null) { setActiveStateMachineActiveTopLevelState(Null); }
    setActiveStateMachine(activeTopLevelState);
  }
  
  //------------------------
  // COPY CONSTRUCTOR
  //------------------------

 Lamp::Lamp(const Lamp & lamp)
  {
    this->log = lamp.log;
  }
  	
  //------------------------
  // Operator =
  //------------------------

 Lamp Lamp::operator=(const Lamp & lamp)
  {
    this->log = lamp.log;
  }

  //------------------------
  // INTERFACE
  //------------------------

  bool Lamp::setLog(const string & aLog)
  {
    bool wasSet = false;
    log = aLog;
    wasSet = true;
    return wasSet;
  }

  string Lamp::getLog() const
  {
    return log;
  }

  string Lamp::getActiveStateMachineFullName()
  {
    string answer = getActiveStateMachineStringName(activeStateMachine);
    if (activeStateMachineActiveTopLevelState != Null) { answer += "." + getActiveStateMachineActiveTopLevelStateStringName(activeStateMachineActiveTopLevelState); }
    return answer;
  }
  
  Lamp::ActiveStateMachine Lamp::getActiveStateMachine()
  {
    return activeStateMachine;
  }

  string Lamp::getActiveStateMachineStringName (ActiveStateMachine activeStateMachine)
  {
    switch (activeStateMachine)  {
      case 0 : {return "activeTopLevelState"; break;}
      default: {return ""; break;}
    }
  }

  Lamp::ActiveStateMachineActiveTopLevelState Lamp::getActiveStateMachineActiveTopLevelState()
  {
    return activeStateMachineActiveTopLevelState;
  }

  string Lamp::getActiveStateMachineActiveTopLevelStateStringName (ActiveStateMachineActiveTopLevelState activeStateMachineActiveTopLevelState)
  {
    switch (activeStateMachineActiveTopLevelState)  {
      case 0 : {return "Null"; break;}
      case 1 : {return "thread1"; break;}
      default: {return ""; break;}
    }
  }

  bool Lamp::enterActiveTopLevelState()
  {
    bool wasEventProcessed = false;

    switch (activeStateMachineActiveTopLevelState)
    {
      case Null:
        setActiveStateMachineActiveTopLevelState(thread1);
        wasEventProcessed = true;
        break;
    }

    return wasEventProcessed;
  }

  bool Lamp::exitActiveTopLevelState()
  {
    bool wasEventProcessed = false;

    switch (activeStateMachineActiveTopLevelState)
    {
      case thread1:
        setActiveStateMachineActiveTopLevelState(Null);
        wasEventProcessed = true;
        break;
    }

    return wasEventProcessed;
  }

  void Lamp::exitActiveStateMachine()
  {
    switch(activeStateMachine)
    {
      case activeTopLevelState:
        exitActiveTopLevelState();
        break;
    }
  }

  void Lamp::setActiveStateMachine(ActiveStateMachine aActiveStateMachine)
  {
    activeStateMachine = aActiveStateMachine;

    // entry actions and do activities
    switch(activeStateMachine)
    {
      case activeTopLevelState:
        if (activeStateMachineActiveTopLevelState == Null) { setActiveStateMachineActiveTopLevelState(thread1); }
        break;
    }
  }
  

  void Lamp::setActiveStateMachineActiveTopLevelState(ActiveStateMachineActiveTopLevelState aActiveStateMachineActiveTopLevelState)
  {
    activeStateMachineActiveTopLevelState = aActiveStateMachineActiveTopLevelState;
    if (activeStateMachine != activeTopLevelState && aActiveStateMachineActiveTopLevelState != Null) { setActiveStateMachine(activeTopLevelState); }

    // entry actions and do activities
    switch(activeStateMachineActiveTopLevelState)
    {
      case thread1:
        doActivityActiveTopLevelStateThread1Thread = new DoActivityThread(this,"doActivityActiveTopLevelStateThread1");
        break;
    }
  }
  

  
  //------------------------
  // DESTRUCTOR
  //------------------------
  
Lamp::~Lamp()
  {}

